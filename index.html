<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="江添 亮" />
  <meta name="date" content="2017-02-28" />
  <title>C++17の新機能</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
  <style>
  pre > code
  {
      display : block ;
      font-family : monospace ;
      font-size : x-large ;
      border-style : solid ;
      border-width : medium ;
      border-color : black ;
      border-radius : 0.4em ;
      padding : 0.5em ;
      word-wrap : break-word ;
      white-space : pre-wrap ;
  }
  
  h1,h2,h3,h4,h5,h6
  {
      font-size : 2em ;
      font-weight : bold ;
  }
  
  table, th, td {
      border: 1px solid black;
      border-collapse: collapse;
      padding : 0.5em ;
  }
  </style>
</head>
<body>
<div id="header">
<h1 class="title">C++17の新機能</h1>
<h2 class="author">江添 亮</h2>
<h3 class="date">2017-02-28</h3>
</div>
<div id="TOC">
<ul>
<li><a href="#序">序</a><ul>
<li><a href="#cの規格">C++の規格</a><ul>
<li><a href="#c98">C++98</a></li>
<li><a href="#c03">C++03</a></li>
<li><a href="#c11">C++11</a></li>
<li><a href="#c14">C++14</a></li>
<li><a href="#c17">C++17</a></li>
</ul></li>
<li><a href="#cの将来の規格">C++の将来の規格</a><ul>
<li><a href="#c20">C++20</a></li>
</ul></li>
<li><a href="#コア言語とライブラリ">コア言語とライブラリ</a></li>
</ul></li>
<li><a href="#sd-6-cのための機能テスト推奨">SD-6 C++のための機能テスト推奨</a><ul>
<li><a href="#機能テストマクロ">機能テストマクロ</a></li>
<li><a href="#has_include式-ヘッダーファイルの存在を判定する">__has_include式 : ヘッダーファイルの存在を判定する</a></li>
<li><a href="#has_cpp_attribute式">__has_cpp_attribute式</a></li>
</ul></li>
<li><a href="#c14のコア言語の新機能">C++14のコア言語の新機能</a><ul>
<li><a href="#二進数リテラル">二進数リテラル</a></li>
<li><a href="#数値区切り文字">数値区切り文字</a></li>
<li><a href="#deprecated属性">[[deprecated]]属性</a></li>
<li><a href="#通常の関数の戻り値の型推定">通常の関数の戻り値の型推定</a></li>
<li><a href="#decltypeauto-厳格なauto">decltype(auto): 厳格なauto</a></li>
<li><a href="#ジェネリックラムダ">ジェネリックラムダ</a></li>
<li><a href="#初期化ラムダキャプチャー">初期化ラムダキャプチャー</a></li>
<li><a href="#変数テンプレート">変数テンプレート</a><ul>
<li><a href="#意味は同じだが型が違う定数">意味は同じだが型が違う定数</a></li>
<li><a href="#traitsのラッパー">traitsのラッパー</a></li>
</ul></li>
<li><a href="#constexpr関数の制限緩和">constexpr関数の制限緩和</a></li>
<li><a href="#メンバー初期化子とアグリゲート初期化の組み合わせ">メンバー初期化子とアグリゲート初期化の組み合わせ</a></li>
<li><a href="#サイズ付き解放関数">サイズ付き解放関数</a></li>
</ul></li>
<li><a href="#c17のコア言語の新機能">C++17のコア言語の新機能</a><ul>
<li><a href="#トライグラフの廃止">トライグラフの廃止</a></li>
<li><a href="#進数浮動小数点数リテラル">16進数浮動小数点数リテラル</a></li>
<li><a href="#utf-8文字リテラル">UTF-8文字リテラル</a></li>
<li><a href="#関数型としての例外指定">関数型としての例外指定</a></li>
<li><a href="#fold式">fold式</a></li>
<li><a href="#ラムダ式でthisのコピーキャプチャー">ラムダ式で*thisのコピーキャプチャー</a></li>
<li><a href="#constexprラムダ式">constexprラムダ式</a></li>
<li><a href="#文字列なしstatic_assert">文字列なしstatic_assert</a></li>
<li><a href="#ネストされた名前空間定義">ネストされた名前空間定義</a></li>
<li><a href="#fallthrough属性">[[fallthrough]]属性</a></li>
<li><a href="#nodiscard属性">[[nodiscard]]属性</a></li>
<li><a href="#maybe_unused属性">[[maybe_unused]]属性</a></li>
<li><a href="#演算子のオペランドの評価順序の固定">演算子のオペランドの評価順序の固定</a></li>
<li><a href="#constexpr-if文-コンパイル時条件分岐">constexpr if文 : コンパイル時条件分岐</a><ul>
<li><a href="#実行時の条件分岐">実行時の条件分岐</a></li>
<li><a href="#プリプロセス時の条件分岐">プリプロセス時の条件分岐</a></li>
<li><a href="#コンパイル時の条件分岐">コンパイル時の条件分岐</a></li>
<li><a href="#超上級者向け解説">超上級者向け解説</a></li>
<li><a href="#constexpr-ifでは解決できない問題">constexpr ifでは解決できない問題</a></li>
<li><a href="#constexpr-ifで解決できる問題">constexpr ifで解決できる問題</a></li>
</ul></li>
<li><a href="#初期化文つき条件文">初期化文つき条件文</a></li>
<li><a href="#クラステンプレートのコンストラクターからの実引数推定">クラステンプレートのコンストラクターからの実引数推定</a><ul>
<li><a href="#実引数ガイド">実引数ガイド</a></li>
</ul></li>
<li><a href="#autoによる非型テンプレートパラメーターの宣言">autoによる非型テンプレートパラメーターの宣言</a></li>
<li><a href="#using属性名前空間">using属性名前空間</a></li>
<li><a href="#非標準属性の無視">非標準属性の無視</a></li>
<li><a href="#構造化束縛">構造化束縛</a><ul>
<li><a href="#超上級者向け解説-1">超上級者向け解説</a></li>
<li><a href="#構造化束縛宣言の仕様">構造化束縛宣言の仕様</a></li>
<li><a href="#初期化子の型が配列の場合">初期化子の型が配列の場合</a></li>
<li><a href="#初期化子の型が配列ではなくstdtuple_sizeeが完全形の名前である場合">初期化子の型が配列ではなく、std::tuple_size&lt;E&gt;が完全形の名前である場合</a></li>
<li><a href="#上記以外の場合">上記以外の場合</a></li>
</ul></li>
<li><a href="#inline変数">inline変数</a><ul>
<li><a href="#inlineの歴史的な意味">inlineの歴史的な意味</a></li>
<li><a href="#現代のinlineの意味">現代のinlineの意味</a></li>
<li><a href="#inline変数の意味">inline変数の意味</a></li>
</ul></li>
<li><a href="#可変長using宣言">可変長using宣言</a></li>
<li><a href="#stdbyte-バイトを表現する型">std::byte バイトを表現する型</a></li>
</ul></li>
<li><a href="#c17の型安全な値を格納するライブラリ">C++17の型安全な値を格納するライブラリ</a><ul>
<li><a href="#variant-型安全なunion">variant : 型安全なunion</a><ul>
<li><a href="#使い方">使い方</a></li>
<li><a href="#型非安全な古典的union">型非安全な古典的union</a></li>
<li><a href="#variantの宣言">variantの宣言</a></li>
<li><a href="#variantの初期化">variantの初期化</a><ul>
<li><a href="#デフォルト初期化">デフォルト初期化</a></li>
<li><a href="#コピー初期化">コピー初期化</a></li>
<li><a href="#variantのコンストラクターに値を渡した場合">variantのコンストラクターに値を渡した場合</a></li>
<li><a href="#in_place_typeによるemplace構築">in_place_typeによるemplace構築</a></li>
</ul></li>
<li><a href="#variantの破棄">variantの破棄</a></li>
<li><a href="#variantの代入">variantの代入</a></li>
<li><a href="#variantのemplace">variantのemplace</a></li>
<li><a href="#variantに値が入っているかどうかの確認">variantに値が入っているかどうかの確認</a><ul>
<li><a href="#valueless_by_exceptionメンバー関数">valueless_by_exceptionメンバー関数</a></li>
<li><a href="#indexメンバー関数">indexメンバー関数</a></li>
</ul></li>
<li><a href="#swap">swap</a></li>
<li><a href="#variant_sizet-variantが保持できる型の数を取得">variant_size&lt;T&gt; : variantが保持できる型の数を取得</a></li>
<li><a href="#variant_alternativei-t-インデックスから型を返す">variant_alternative&lt;I, T&gt; : インデックスから型を返す</a></li>
<li><a href="#holds_alternative-variantが指定した型の値を保持しているかどうかの確認">holds_alternative : variantが指定した型の値を保持しているかどうかの確認</a></li>
<li><a href="#getiv-インデックスから値の取得">get&lt;I&gt;(v) : インデックスから値の取得</a></li>
<li><a href="#gettv-型から値の取得">get&lt;T&gt;(v) : 型から値の取得</a></li>
<li><a href="#get_if-値を保持している場合に取得">get_if : 値を保持している場合に取得</a></li>
<li><a href="#variantの比較">variantの比較</a><ul>
<li><a href="#同一性の比較">同一性の比較</a></li>
<li><a href="#大小比較">大小比較</a></li>
</ul></li>
<li><a href="#visit-variantが保持している値を受け取る">visit : variantが保持している値を受け取る。</a></li>
</ul></li>
<li><a href="#any-どんな型の値でも保持できるクラス">any : どんな型の値でも保持できるクラス</a><ul>
<li><a href="#使い方-1">使い方</a></li>
<li><a href="#anyの構築と破棄">anyの構築と破棄</a></li>
<li><a href="#in_place_typeコンストラクター">in_place_typeコンストラクター</a></li>
<li><a href="#anyへの代入">anyへの代入</a></li>
<li><a href="#anyのメンバー関数">anyのメンバー関数</a><ul>
<li><a href="#emplace">emplace</a></li>
<li><a href="#reset-値の破棄">reset : 値の破棄</a></li>
<li><a href="#swap-スワップ">swap : スワップ</a></li>
<li><a href="#has_value-値を保持しているかどうか調べる">has_value : 値を保持しているかどうか調べる</a></li>
<li><a href="#type-保持している型のtype_infoを得る">type : 保持している型のtype_infoを得る</a></li>
</ul></li>
<li><a href="#anyのフリー関数">anyのフリー関数</a><ul>
<li><a href="#make_anyt-t型のanyを作る">make_any&lt;T&gt; : T型のanyを作る</a></li>
<li><a href="#any_cast-保持している値の取り出し">any_cast : 保持している値の取り出し</a></li>
</ul></li>
</ul></li>
<li><a href="#optional-値を保有しているかしていないクラス">optional : 値を保有しているか、していないクラス</a><ul>
<li><a href="#使い方-2">使い方</a></li>
<li><a href="#optionalのテンプレート実引数">optionalのテンプレート実引数</a></li>
<li><a href="#optionalの構築">optionalの構築</a></li>
<li><a href="#optionalの代入">optionalの代入</a></li>
<li><a href="#optionalの破棄">optionalの破棄</a></li>
<li><a href="#swap-1">swap</a></li>
<li><a href="#has_value-値を保持しているかどうか確認する">has_value : 値を保持しているかどうか確認する</a></li>
<li><a href="#value-保持している値を取得">value : 保持している値を取得</a></li>
<li><a href="#value_or-値もしくはデフォルト値を返す">value_or : 値もしくはデフォルト値を返す</a></li>
<li><a href="#reset-保持している値を破棄する">reset : 保持している値を破棄する</a></li>
<li><a href="#optional同士の比較">optional同士の比較</a><ul>
<li><a href="#同一性の比較-1">同一性の比較</a></li>
<li><a href="#大小比較-1">大小比較</a></li>
</ul></li>
<li><a href="#optionalとstdnullpotとの比較">optionalとstd::nullpotとの比較</a></li>
<li><a href="#optionaltとtの比較">optional&lt;T&gt;とTの比較</a></li>
<li><a href="#make_optionalt-optionaltを返す">make_optional&lt;T&gt; : optional&lt;T&gt;を返す</a></li>
<li><a href="#make_optionalt-args-...-optionaltをin_place_type構築して返す">make_optional&lt;T, Args ... &gt; : optional&lt;T&gt;をin_place_type構築して返す</a></li>
</ul></li>
</ul></li>
<li><a href="#string_view-文字列ラッパー">string_view : 文字列ラッパー</a><ul>
<li><a href="#使い方-3">使い方</a></li>
<li><a href="#basic_string_view">basic_string_view</a></li>
<li><a href="#文字列の所有非所有">文字列の所有、非所有</a></li>
<li><a href="#string_viewの構築">string_viewの構築</a><ul>
<li><a href="#デフォルト構築">デフォルト構築</a></li>
<li><a href="#null終端された文字型の配列へのポインター">null終端された文字型の配列へのポインター</a></li>
<li><a href="#文字型へのポインターと文字数">文字型へのポインターと文字数</a></li>
</ul></li>
<li><a href="#文字列クラスからの変換関数">文字列クラスからの変換関数</a></li>
<li><a href="#string_viewの操作">string_viewの操作</a><ul>
<li><a href="#remove_prefixremove_suffix-先頭末尾の要素の削除">remove_prefix/remove_suffix : 先頭、末尾の要素の削除</a></li>
</ul></li>
<li><a href="#ユーザー定義リテラル">ユーザー定義リテラル</a></li>
</ul></li>
<li><a href="#メモリーリソース-動的ストレージ確保ライブラリ">メモリーリソース : 動的ストレージ確保ライブラリ</a><ul>
<li><a href="#メモリーリソース">メモリーリソース</a><ul>
<li><a href="#メモリーリソースの使い方">メモリーリソースの使い方</a></li>
<li><a href="#メモリーリソースの作り方">メモリーリソースの作り方</a></li>
</ul></li>
<li><a href="#polymorphic_allocator-動的ポリモーフィズムを実現するアロケーター">polymorphic_allocator : 動的ポリモーフィズムを実現するアロケーター</a><ul>
<li><a href="#コンストラクター">コンストラクター</a></li>
</ul></li>
<li><a href="#プログラム全体で使われるメモリーリソースの取得">プログラム全体で使われるメモリーリソースの取得</a><ul>
<li><a href="#new_delete_resource">new_delete_resource()</a></li>
<li><a href="#null_memory_resource">null_memory_resource()</a></li>
<li><a href="#デフォルトリソース">デフォルトリソース</a></li>
</ul></li>
<li><a href="#標準ライブラリのメモリーリソース">標準ライブラリのメモリーリソース</a></li>
<li><a href="#プールリソース">プールリソース</a><ul>
<li><a href="#アルゴリズム">アルゴリズム</a></li>
<li><a href="#synchronizedunsynchronized_pool_resource">synchronized/unsynchronized_pool_resource</a></li>
<li><a href="#pool_options">pool_options</a></li>
<li><a href="#プールリソースのコンストラクター">プールリソースのコンストラクター</a></li>
<li><a href="#プールリソースのメンバー関数">プールリソースのメンバー関数</a><ul>
<li><a href="#release">release()</a></li>
<li><a href="#upstream_resource">upstream_resource()</a></li>
<li><a href="#options">options()</a></li>
</ul></li>
</ul></li>
<li><a href="#モノトニックバッファーリソース">モノトニックバッファーリソース</a><ul>
<li><a href="#アルゴリズム-1">アルゴリズム</a></li>
<li><a href="#コンストラクター-1">コンストラクター</a></li>
<li><a href="#その他の操作">その他の操作</a><ul>
<li><a href="#release-1">release()</a></li>
<li><a href="#upstream_resource-1">upstream_resource()</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#並列アルゴリズム">並列アルゴリズム</a><ul>
<li><a href="#並列実行について">並列実行について</a></li>
<li><a href="#使い方-4">使い方</a></li>
<li><a href="#並列アルゴリズム詳細">並列アルゴリズム詳細</a><ul>
<li><a href="#並列アルゴリズム-1">並列アルゴリズム</a></li>
<li><a href="#ユーザー提供する関数オブジェクトの制約">ユーザー提供する関数オブジェクトの制約</a><ul>
<li><a href="#実引数で与えられたオブジェクトを直接間接に変更してはならない">実引数で与えられたオブジェクトを直接、間接に変更してはならない</a></li>
<li><a href="#実引数で与えられたオブジェクトの一意性に依存してはならない">実引数で与えられたオブジェクトの一意性に依存してはならない</a></li>
<li><a href="#データ競合と同期">データ競合と同期</a></li>
</ul></li>
<li><a href="#例外">例外</a></li>
<li><a href="#実行ポリシー">実行ポリシー</a><ul>
<li><a href="#is_execution_policy-traits">is_execution_policy traits</a></li>
<li><a href="#シーケンス実行ポリシー">シーケンス実行ポリシー</a></li>
<li><a href="#パラレル実行ポリシー">パラレル実行ポリシー</a></li>
<li><a href="#パラレル非シーケンス実行ポリシー">パラレル非シーケンス実行ポリシー</a></li>
<li><a href="#実行ポリシーオブジェクト">実行ポリシーオブジェクト</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="序">序</h1>
<p>本書が出版される頃には、すでにC++17規格が正式に制定されているだろう。本書はC++17の新機能をいち早く解説するために書かれた。</p>
<h2 id="cの規格">C++の規格</h2>
<p>プログラミング言語C++はISOの傘下で国際規格ISO/IEC 14882として制定されている。この規格は数年おきに改定されている。一般にC++の規格を参照するときは、規格が制定した西暦の下二桁をとって、C++98(1998年発行)とかC++11(2011年発行)と呼ばれている。現在発行されているC++の規格は以下の通り。</p>
<h3 id="c98">C++98</h3>
<p>C++98は1998年に制定された最初のC++の規格である。本来ならば1994年か1995年には制定させる予定が大幅にずれて、1998年となった。</p>
<h3 id="c03">C++03</h3>
<p>C++03はC++98の文面の曖昧な点を修正したマイナーアップデートとして2003年に制定された。新機能の追加はほとんどない。</p>
<h3 id="c11">C++11</h3>
<p>C++11は制定途中のドラフト段階では元C++0xと呼ばれていた。これは、200x年までに規格が制定される予定だったからだ。予定は大幅に遅れ、ようやく規格が制定された時にはすでに2011年の年末になっていた。C++11ではとても多くの新機能が追加された。</p>
<h3 id="c14">C++14</h3>
<p>C++14は2014年に制定された。C++11の文面の誤りを修正した他、すこし新機能が追加された。本書で解説する。</p>
<h3 id="c17">C++17</h3>
<p>C++17は2017年に制定されることが予定されている最新のC++規格で、本書で解説する。</p>
<h2 id="cの将来の規格">C++の将来の規格</h2>
<h3 id="c20">C++20</h3>
<p>C++20は2020年に制定されることが予定されている次のC++規格だ。この規格では、モジュール、コンセプト、レンジ、ネットワークに注力することが予定されている。</p>
<h2 id="コア言語とライブラリ">コア言語とライブラリ</h2>
<p>C++の標準規格は、大きく分けて、Cプリプロセッサーとコア言語とライブラリからなる。</p>
<p>Cプリプロセッサーとは、C++がC言語から受け継いだ機能だ。ソースファイルをトークン列単位で分割して、トークン列の置換ができる。</p>
<p>コア言語とは、ソースファイルに書かれたトークン列の文法とその意味のことだ。</p>
<p>ライブラリとは、コア言語機能を使って実装されたもので、標準に提供されているものだ。標準ライブラリには、純粋にコア言語の機能のみで実装できるものと、それ以外の実装依存の方法やコンパイラーマジックが必要なものとがある。</p>
<h1 id="sd-6-cのための機能テスト推奨">SD-6 C++のための機能テスト推奨</h1>
<p>C++17には機能テストのためのCプリプロセッサー機能が追加された。</p>
<h2 id="機能テストマクロ">機能テストマクロ</h2>
<p>機能テストというのは、C++の実装(C++コンパイラー)が特定の機能をサポートしているかどうかをコンパイル時に判断できる機能だ。本来、C++17の規格に準拠したC++実装は、C++17の機能をすべてサポートしているべきだ。しかし、残念ながら現実のC++コンパイラーの開発はそのようには行われていない。C++17に対応途中のC++コンパイラーは将来的にはすべての機能を実装することを目標としつつも、現時点では一部の機能しか実装していないという状態になる。</p>
<p>例えば、C++11で追加されたrvalueリファレンスという機能に現実のC++コンパイラーが対応しているかどうかをコンパイル時に判定するコードは以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifndef __USE_RVALUE_REFERENCES</span>
  <span class="pp">#if (__GNUC__ &gt; 4 || __GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 3) || \</span>
<span class="pp">      _MSC_VER &gt;= 1600</span>
    <span class="pp">#if __EDG_VERSION__ &gt; 0</span>
      <span class="pp">#define __USE_RVALUE_REFERENCES (__EDG_VERSION__ &gt;= 410)</span>
    <span class="pp">#else</span>
      <span class="pp">#define __USE_RVALUE_REFERENCES 1</span>
    <span class="pp">#endif</span>
  <span class="pp">#elif __clang__</span>
    <span class="pp">#define __USE_RVALUE_REFERENCES __has_feature(cxx_rvalue_references)</span>
  <span class="pp">#else</span>
    <span class="pp">#define __USE_RVALUE_REFERENCES 0</span>
  <span class="pp">#endif</span>
<span class="pp">#endif</span></code></pre></div>
<p>このそびえ立つクソのようなコードは現実に書かれている。このコードはGCCとMSVCとEDGとClangという現実に使われている主要な4つのC++コンパイラーに対応したrvalueリファレンスが実装されているかどうかを判定する機能テストコードだ。</p>
<p>この複雑なプリプロセッサーを解釈した結果、__USE_RVALUE_REFERENCESというプリプロセッサーマクロの値が、もしC++コンパイラーがrvalueリファレンスをサポートしているならば1、そうでなければ0となる。あとは、このプリプロセッサーマクロで#ifガードしたコードを書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 文字列を処理する関数</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string <span class="at">const</span> &amp; str ) ;

<span class="pp">#if __USE_RVALUE_REFERENCES == 1</span>
<span class="co">// 文字列をムーブして処理してよい実装の関数</span>
<span class="co">// C++コンパイラーがrvalueリファレンスを実装していない場合はコンパイルされない</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string &amp;&amp; str ) ;
<span class="pp">#endif</span></code></pre></div>
<p>C++17では、上のようなそびえ立つクソのようなコードを書かなくてもすむように、標準の機能テストマクロが用意された。C++実装が特定の機能をサポートしている場合、対応する機能テストマクロが定義される。機能テストマクロの値は、その機能がC++標準に採択された年と月を合わせた6桁の整数で表現される。</p>
<p>例えばrvalueリファレンスの場合、機能テストマクロの名前は__cpp_rvalue_referencesとなっている。rvalueリファレンスは2006年10月に採択されたので、機能テストマクロの値は200610という値になっている。将来rvalueリファレンスの機能が変更された時は機能テストマクロの値も変更される。この値を調べることによって使っているC++コンパイラーはいつの時代のC++標準の機能をサポートしているか調べることもできる。</p>
<p>この機能テストマクロを使うと、上のコードの判定は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 文字列を処理する関数</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string <span class="at">const</span> &amp; str ) ;

<span class="pp">#ifndef __cpp_rvalue_references</span>
<span class="co">// 文字列をムーブして処理してよい実装の関数</span>
<span class="co">// C++コンパイラーがrvalueリファレンスを実装していない場合はコンパイルされない</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string &amp;&amp; str ) ;
<span class="pp">#endif</span></code></pre></div>
<p>機能テストマクロの値は通常は気にする必要がない。機能テストマクロが存在するかどうかで機能の有無を確認できるので、通常は#ifdefを使えばよい。</p>
<h2 id="has_include式-ヘッダーファイルの存在を判定する">__has_include式 : ヘッダーファイルの存在を判定する</h2>
<p>__has_include式は、ヘッダーファイルが存在するかどうかを調べるための機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">__has_include( ヘッダー名 )</code></pre></div>
<p>__has_include式はヘッダー名が存在する場合1に、存在しない場合0に置換される。</p>
<p>例えば、C++17の標準ライブラリにはファイルシステムが入る。そのヘッダー名は&lt;filesystem&gt;だ。C++コンパイラーがファイルシステムライブラリをサポートしているかどうかを調べるには、以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#if __has_include(&lt;filesystem&gt;) </span>
<span class="co">// ファイルシステムをサポートしている</span>
<span class="pp">#include </span><span class="im">&lt;filesystem&gt;</span>
<span class="kw">namespace</span> fs = <span class="bu">std::</span>filesystem
<span class="pp">#else</span>
<span class="co">// 実験的な実装を使う</span>
<span class="pp">#include </span><span class="im">&lt;experimental/filesystem&gt;</span>
<span class="kw">namespace</span> fs = <span class="bu">std::</span>experimental<span class="bu">::</span>filesystem ;
<span class="pp">#endif</span></code></pre></div>
<p>C++実装が__has_includeをサポートしているかどうかは、__has_includeの存在をプリプロセッサーマクロのように#ifdefで調べることによって判定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#ifdef __has_include</span>
<span class="co">// __has_includeをサポートしている</span>
<span class="pp">#else</span>
<span class="co">// __has_includeをサポートしていない</span>
<span class="pp">#endif</span></code></pre></div>
<p>__has_include式は#ifと#elifの中でしか使えない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー</span>
    <span class="cf">if</span> ( __has_include(&lt;vector&gt;) )
    { }
}</code></pre></div>
<h2 id="has_cpp_attribute式">__has_cpp_attribute式</h2>
<p>C++実装が特定の属性トークンをサポートしているかどうかをしらべるには、__has_cpp_attribute式が使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">__has_cpp_attribute( 属性トークン )</code></pre></div>
<p>__has_cpp_attribute式は、属性トークンが存在する場合は属性トークンが標準規格に採択された年と月を表す数値に、存在しない場合は0に置換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// [[nodiscard]]がサポートされている場合は使う</span>
<span class="pp">#if __has_cpp_attribute(nodiscard)</span>
[[<span class="at">nodiscard</span>]]
<span class="pp">#endif</span>
<span class="dt">void</span> * allocate_memory( <span class="bu">std::</span>size_t size ) ;</code></pre></div>
<p>__has_include式と同じく、__has_cpp_attribute式も#ifか#elifの中でしか使えない。#ifdefで__has_cpp_attribute式の存在の有無を判定できる。</p>
<h1 id="c14のコア言語の新機能">C++14のコア言語の新機能</h1>
<p>C++14で追加された新機能は少ない。C++14はC++03と同じくマイナーアップデートという位置づけで積極的な新機能の追加は見送られたからだ。</p>
<h2 id="二進数リテラル">二進数リテラル</h2>
<p>二進数リテラルは整数リテラルを二進数で記述する機能だ。整数リテラルのプレフィクスに0Bもしくは0bを書くと、二進数リテラルになる。整数を表現する文字は0と1しか使えない</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x1 = <span class="bn">0b0</span> ; <span class="co">// 0</span>
    <span class="dt">int</span> x2 = <span class="bn">0b1</span> ; <span class="co">// 1</span>
    <span class="dt">int</span> x3 = <span class="bn">0b10</span> ; <span class="co">// 2</span>
    <span class="dt">int</span> x4 = <span class="bn">0b11001100</span> ; <span class="co">// 204</span>
}</code></pre></div>
<p>二進数リテラルは浮動小数点数リテラルには使えない。</p>
<p>機能テストマクロは__cpp_binary_literals。値は201304</p>
<h2 id="数値区切り文字">数値区切り文字</h2>
<p>数値区切り文字は、整数リテラルと浮動小数点数リテラルの数値をシングルクオート文字で区切ることができる機能だ。区切り桁は何桁でもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x1 = <span class="dv">123&#39;456&#39;789</span> ;
    <span class="dt">int</span> x2 = <span class="dv">1&#39;2&#39;3&#39;4&#39;5&#39;6&#39;7&#39;8&#39;9</span> ; 
    <span class="dt">int</span> x3 = <span class="dv">1&#39;2345&#39;6789</span> ;
    <span class="dt">int</span> x4 = <span class="dv">1&#39;23&#39;456&#39;789</span> ;

    <span class="dt">double</span> x5 = <span class="fl">3.14159</span><span class="st">&#39;26535&#39;</span><span class="dv">89793</span> ;
}</code></pre></div>
<p>大きな数値を扱うとき、ソースファイルに100000000と1000000000と書かれていた場合、どちらが大きいのか人間の目にはわかりにくい。人間が読んでわかりにくいコードは間違いの元だ。数値区切りを使うと、100'000'000と1000'000'000のように書くことができる。これはわかりやすい。</p>
<p>他には、1バイト単位で見やすいように区切ることもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">unsigned</span> <span class="dt">int</span> x1 = <span class="bn">0xde&#39;ad&#39;be&#39;ef</span> ;
    <span class="dt">unsigned</span> <span class="dt">int</span> x2 = <span class="bn">0b11011110&#39;10101101&#39;10111110&#39;11101111</span> ;
}</code></pre></div>
<p>数値区切りはソースファイルを人間が読みやすくするための機能で、数値に影響を与えない。</p>
<h2 id="deprecated属性">[[deprecated]]属性</h2>
<p>[[deprecated]]属性は名前とエンティティが、まだ使えるものの利用は推奨されない状態であることを示すのに使える。deprecated属性が指定できる名前とエンティティは、クラス、typedef名、変数、非staticデータメンバー、関数、名前空間、enum、enumerator、テンプレートの特殊化だ</p>
<p>それぞれ以下のように指定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 変数</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">deprecated</span>]] <span class="dt">int</span> variable_name1 { } ;
<span class="dt">int</span> variable_name2 [[<span class="at">deprecated</span>]] { }

<span class="co">// typedef名</span>
[[<span class="at">deprecated</span>]] <span class="kw">typedef</span> <span class="dt">int</span> typedef_name1 ;
<span class="kw">typedef</span> <span class="dt">int</span> typedef_name2 [[<span class="at">deprecated</span>]] ;
<span class="kw">using</span> typedef_name3 [[<span class="at">deprecated</span>]] = <span class="dt">int</span> ;

<span class="co">// 関数</span>
<span class="co">// メンバー関数も同じ文法</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">deprecated</span>]] <span class="dt">void</span> function_name1() { }
<span class="dt">void</span> function_name2 [[<span class="at">deprecated</span>]] { }


<span class="co">// クラス</span>
<span class="co">// unionも同じ</span>
<span class="kw">class</span> [[<span class="at">deprecated</span>]] class_name
{
<span class="co">// 非staticデータメンバー</span>
[[<span class="at">deprecated</span>]] <span class="dt">int</span> non_static_data_member_name ;
} ;

<span class="co">// enum</span>
<span class="kw">enum</span> <span class="kw">class</span> [[<span class="at">deprecated</span>]] enum_name
{
<span class="co">// enumerator</span>
enumerator_name [[<span class="at">deprecated</span>]] = <span class="dv">42</span>
} ;


<span class="co">// 名前空間</span>
<span class="kw">namespace</span> [[<span class="at">deprecated</span>]] namespace_name { <span class="dt">int</span> x ; }

<span class="co">// テンプレートの特殊化</span>

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> template_name { } ;

<span class="kw">template</span> &lt; &gt;
<span class="kw">class</span> [[<span class="at">deprecated</span>]] template_name&lt;<span class="dt">void</span>&gt; { }</code></pre></div>
<p>deprecated属性が指定された名前やエンティティを使うと、C++コンパイラーは警告メッセージを出す。</p>
<p>deprecated属性には、文字列を付け加えることができる。これはC++実装によっては警告メッセージに含まれるかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[<span class="at">deprecated</span>(<span class="st">&quot;Use of f() is deprecated. Use f(int option) instead.&quot;</span>)]] <span class="dt">void</span> f() ;

<span class="dt">void</span> f( <span class="dt">int</span> option ) ;</code></pre></div>
<p>機能テストマクロは__has_cpp_attribute(deprecated)。値は201309。</p>
<h2 id="通常の関数の戻り値の型推定">通常の関数の戻り値の型推定</h2>
<p>関数の戻り値の型としてautoを指定すると、戻り値の型をreturn文から推定してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int ()</span>
<span class="kw">auto</span> a(){ <span class="cf">return</span> <span class="dv">0</span> ; }
<span class="co">// double ()</span>
<span class="kw">auto</span> b(){ <span class="cf">return</span> <span class="fl">0.0</span> ; }

<span class="co">// T(T)</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">auto</span> c(T t){ <span class="cf">return</span> t ; }</code></pre></div>
<p>return文の型が一致していないとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> f()
{
    <span class="cf">return</span> <span class="dv">0</span> ; <span class="co">// エラー、一致してない</span>
    <span class="cf">return</span> <span class="fl">0.0</span> ; <span class="co">// エラー、一致していない</span>
}</code></pre></div>
<p>すでに型が決定できるreturn文が存在する場合、関数の戻り値の型を参照するコードも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> a()
{
    &amp;a ; <span class="co">// エラー、aの戻り値の型が決定していない</span>
    <span class="cf">return</span> <span class="dv">0</span> ;
}

<span class="kw">auto</span> b()
{
    <span class="cf">return</span> <span class="dv">0</span> ;
    &amp;b ; <span class="co">// OK、戻り値の型はint</span>
}</code></pre></div>
<p>関数aへのポインターを使うには関数aの型が決定していなければならないが、return文の前に型は決定できないので関数aはエラーになる。関数bはreturn文が現れた後なので戻り値の型が決定できる。</p>
<p>再帰関数も書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> sum( <span class="dt">unsigned</span> <span class="dt">int</span> i )
{
    <span class="cf">if</span> ( i == <span class="dv">0</span> )
        <span class="cf">return</span> i ; <span class="co">// 戻り値の型はunsigned int</span>
    <span class="cf">else</span>
        <span class="cf">return</span> sum(i<span class="dv">-1</span>)+i ; <span class="co">// OK</span>
}</code></pre></div>
<p>このコードも、return文の順番を逆にすると戻り値の型が決定できずエラーとなるので注意。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> sum( <span class="dt">unsigned</span> <span class="dt">int</span> i )
{
    <span class="cf">if</span> ( i != <span class="dv">0</span> )
        <span class="cf">return</span> sum(i<span class="dv">-1</span>)+i ; <span class="co">// エラー</span>
    <span class="cf">else</span>
        <span class="cf">return</span> i ;
}</code></pre></div>
<p>機能テストマクロは__cpp_return_type_deduction。値は201304。</p>
<h2 id="decltypeauto-厳格なauto">decltype(auto): 厳格なauto</h2>
<p>警告：この項目はC++規格の詳細な知識を解説しているため極めて難解になっている。平均的なC++プログラマーはこの知識を得てもよりよいコードが書けるようにはならない。この項目は読み飛ばすべきである。</p>
<p>decltype(auto)はauto指定子の代わりに使える厳格なautoだ。利用にはC++の規格の厳格な理解が求められる。</p>
<p>autoとdecltype(auto)は型指定子と呼ばれる文法の一種で、プレイスホルダー型として使う。</p>
<p>わかりやすく言うと、具体的な型を式から決定する機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// aはint</span>
<span class="kw">auto</span> a = <span class="dv">0</span> ;
<span class="co">// bはint </span>
<span class="kw">auto</span> b() { <span class="cf">return</span> <span class="dv">0</span> ; } </code></pre></div>
<p>変数宣言にプレイスホルダー型を使う場合、型を決定するための式は初期化子と呼ばれる部分に書かれる式を使う。関数の戻り値の型推定にプレイスホルダー型を使う場合、return文の式を使う。</p>
<p>decltype(auto)はautoの代わりに使うことができる。delctype(auto)も型を式から決定する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// aはint</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="dv">0</span> ;
<span class="co">// bはint</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) b() { <span class="cf">return</span> <span class="dv">0</span> ; }</code></pre></div>
<p>一見するとautoとdecltype(auto)は同じようだ。しかし、この2つは式から型を決定する方法が違う。どちらもC++の規格の極めて難しい規則に基づいて決定される。習得には熟練の魔法使いであることが要求される。</p>
<p>autoが式から型を決定するには、autoキーワードをテンプレートパラメーター名で置き換えた関数テンプレートの仮引数に、式を実引数として渡してテンプレート実引数推定を行わせた場合に推定される型が使われる。</p>
<p>例えば</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> x = <span class="dv">0</span> ;</code></pre></div>
<p>の場合は、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T u ) ;</code></pre></div>
<p>のような関数テンプレートに対して、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">f(<span class="dv">0</span>) ;</code></pre></div>
<p>と実引数を渡した時にuの型として推定される型と同じ型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> i ;
<span class="kw">auto</span> <span class="at">const</span> * x = &amp;i ;</code></pre></div>
<p>の場合には、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T <span class="at">const</span> * u ) ;</code></pre></div>
<p>のような関数テンプレートに</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">f(&amp;i) ;</code></pre></div>
<p>と実引数を渡した時にuの型として推定される型と同じ型になる。この場合はint const *になる。</p>
<p>ここまでがautoの説明だ。decltype(auto)の説明は簡単だ。</p>
<p>decltype(auto)の型は、autoを式で置き換えたdecltypeの型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="dv">0</span> ;

<span class="co">// int</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) f() { <span class="cf">return</span> <span class="dv">0</span> ; }</code></pre></div>
<p>上のコードは、下のコードと同じ意味だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">decltype</span>(<span class="dv">0</span>) a = <span class="dv">0</span> ;
<span class="kw">decltype</span>(<span class="dv">0</span>) f() { <span class="cf">return</span> <span class="dv">0</span> ; }</code></pre></div>
<p>ここまでは簡単だ。そして、これ以降は黒魔術のようなC++の規格の知識が必要になってくる。</p>
<p>autoとdecltype(auto)は一見すると同じように見える。型を決定する方法として、autoは関数テンプレートの実引数推定を使い、decltype(auto)はdecltypeを使う。どちらも式を評価した結果の型になる。一体何が違うというのか。</p>
<p>主な違いは、autoは関数呼び出しを使うということだ。関数呼び出しの際には様々な暗黙の型変換が行われる。</p>
<p>例えば、配列を関数に渡すと、暗黙の型変換の結果、配列の先頭要素へのポインターになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T u ) {}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> array[<span class="dv">5</span>] ;
    <span class="co">// Tはint *</span>
    f( array ) ;
}</code></pre></div>
<p>ではautoとdecltype(auto)を使うとどうなるのか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> array[<span class="dv">5</span>] ;
<span class="co">// int *</span>
<span class="kw">auto</span> x1 = array ;
<span class="co">// エラー、配列は配列で初期化できない</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = array ;</code></pre></div>
<p>このコードは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> array[<span class="dv">5</span>] ;
<span class="co">// int *</span>
<span class="dt">int</span> * x1 = array ;
<span class="co">// エラー、配列は配列で初期化できない</span>
<span class="dt">int</span> x2[<span class="dv">5</span>] = array ;</code></pre></div>
<p>autoの場合、型はint *となる。配列は配列の先頭要素へのポインターへと暗黙に変換できるので、結果のコードは正しい。</p>
<p>decltype(auto)の場合、型はint [5]となる。配列は配列で初期化、代入ができないので、このコードはエラーになる。</p>
<p>関数型も暗黙の型変換により関数へのポインター型になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() ;

<span class="co">// 型はvoid(*)()</span>
<span class="kw">auto</span> x1 = f ;
<span class="co">// エラー、関数型は変数にできない</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = f ;</code></pre></div>
<p>autoはトップレベルのリファレンス修飾子を消すが、decltype(auto)は保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> &amp; f()
{
    <span class="at">static</span> <span class="dt">int</span> x ;
    <span class="cf">return</span> x ;
}

<span class="dt">int</span> main()
{
    <span class="co">// int</span>
    <span class="kw">auto</span> x1 = f() ;
    <span class="co">// int &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = f() ;
}</code></pre></div>
<p>autoはトップレベルのCV修飾子を消すが、decltype(auto)は保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int</span>
    <span class="kw">auto</span> x1 = f() ;
    <span class="co">// int &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = f() ;
}</code></pre></div>
<p>リスト初期化はautoではstd::initializer_listだが、decltype(auto)では式ではないためエラー</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// std::initializer_list&lt;int&gt;</span>
    <span class="kw">auto</span> x1 = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
    <span class="co">// エラー、decltype({1,2,3})はできない</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) x2 = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
}</code></pre></div>
<p>decltype(auto)は単体で使わなければならない。</p>
<pre class="c+"><code>// OK
auto const x1 = 0 ; 
// エラー
decltype(auto) const x2 = 0 ;</code></pre>
<p>この他にもautoとdecltype(auto)には様々な違いがある。すべての違いを列挙するのは煩雑なので省略するが、decltype(auto)は式の型を直接使う。autoは大抵の場合は便利な型の変換が入る。</p>
<p>autoは便利で大抵の場合はうまく行くが暗黙の型の変換が入るため、意図通りの推定をしてくれないことがある。</p>
<p>例えば、引数でリファレンスを受け取り、戻り値でそのリファレンスを返す関数を書くとする。以下のように書くのは間違いだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int ( int &amp; )</span>
<span class="kw">auto</span> f( <span class="dt">int</span> &amp; ref )
{ <span class="cf">return</span> ref ; }</code></pre></div>
<p>なぜならば、戻り値の型は式の型から変化してintになってしまうからだ。ここでdecltype(auto)を使うと、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int &amp; ( int &amp; )</span>
<span class="kw">decltype</span>(<span class="kw">auto</span>) f( <span class="dt">int</span> &amp; ref )
{ <span class="cf">return</span> ref ; }</code></pre></div>
<p>式の型をそのまま使ってくれる。</p>
<p>ラムダ式にdelctype(auto)を使う場合は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[]() -&gt; <span class="kw">decltype</span>(<span class="kw">auto</span>) { <span class="cf">return</span> <span class="dv">0</span> ; } ;</code></pre></div>
<p>decltype(auto)は主に関数の戻り地の型推定で式の型をそのまま推定してくれるようにするために追加された機能だ。その利用にはC++の型システムの深い理解が必要になる。</p>
<p>機能テストマクロは__cpp_decltype_auto, 値は201304。</p>
<h2 id="ジェネリックラムダ">ジェネリックラムダ</h2>
<p>ジェネリックラムダはラムダ式の引数の型を書かなくてもすむようにする機能だ。</p>
<p>通常のラムダ式は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    []( <span class="dt">int</span> i, <span class="dt">double</span> d, <span class="bu">std::</span>string s ) { } ;
}</code></pre></div>
<p>ラムダ式の引数には型が必要だ。しかし、クロージャーオブジェクトのoperator ()に渡す型はコンパイル時にわかる。コンパイル時にわかるということはわざわざ人間が指定する必要はない。ジェネリックラムダを使えば、引数の型を書くべき場所にautoキーワードを書くだけで型を推定してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    []( <span class="kw">auto</span> i, <span class="kw">auto</span> d, <span class="kw">auto</span> s ) { } ;
}</code></pre></div>
<p>ジェネリックラムダ式の結果のクロージャー型には呼出しごとに違う型を渡すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []( <span class="kw">auto</span> x ) { <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ; } ;

    f( <span class="dv">123</span> ) ; <span class="co">// int</span>
    f( <span class="fl">12.3</span> ) ; <span class="co">// double</span>
    f( <span class="st">&quot;hello&quot;</span> ) ; <span class="co">// char const *</span>
}</code></pre></div>
<p>仕組みは簡単で、以下のようなメンバーテンプレートのoperator ()を持ったクロージャーオブジェクトが生成されているだけだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> closure_object
{
    <span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
    <span class="kw">auto</span> <span class="kw">operator</span> () ( T x )
    {
        <span class="bu">std::</span>cout &lt;&lt; x &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
} ;</code></pre></div>
<p>機能テストマクロは__cpp_generic_lambdas, 値は201304。</p>
<h2 id="初期化ラムダキャプチャー">初期化ラムダキャプチャー</h2>
<p>初期化ラムダキャプチャーはラムダキャプチャーする変数の名前と式を書くことができる機能だ。</p>
<p>ラムダ式は書かれた場所から見えるスコープの変数をキャプチャーする</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    <span class="kw">auto</span> f = [=]{ <span class="cf">return</span> x ; } ;
    f() ;
}</code></pre></div>
<p>初期化ラムダキャプチャーはラムダキャプチャーに初期化子を書くことができる機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    [ x = x, y = x, &amp;ref = x, x2 = x * <span class="dv">2</span> ]
    {<span class="co">// キャプチャーされた変数を使う</span>
        x ;
        y ;
        ref ;
        val ;
    } ;
}</code></pre></div>
<p>初期化ラムダキャプチャーは、&quot;識別子 = expr&quot; という文法でラムダ導入子[]の中に書く。するとあたかも&quot;auto 識別子 = expr ;&quot;と書いたかのように変数が作られる。これによりキャプチャーする変数の名前を変えたり、まったく新しい変数を宣言することができる。</p>
<p>初期化ラムダキャプチャーの識別子の前に&amp;をつけると、リファレンスキャプチャー扱いになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> x = <span class="dv">0</span> ;
    [ &amp;ref = x ]()
    {
        ref = <span class="dv">1</span> ;
    }() ;

    <span class="co">// xは1</span>
}</code></pre></div>
<p>初期化ラムダキャプチャーが追加された理由には変数の名前を変えたり全く新しい変数を導入したいという目的の他に、非staticデータメンバーをコピーキャプチャーするという目的がある。</p>
<p>以下のコードには問題があるが、わかるだろうか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> data = <span class="dv">42</span> ;

    <span class="kw">auto</span> get_closure_object()
    {
        <span class="cf">return</span> [=]{ <span class="cf">return</span> data ; } ;
    }
} ;


<span class="dt">int</span> main()
{
    <span class="bu">std::</span>function&lt; <span class="dt">int</span>() &gt; f ;

    {
        X x ;
        f = x.get_closure_object() ;
    }

    <span class="bu">std::</span>cout &lt;&lt; f() &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>X::get_closure_objectはX::dataを返すクロージャーオブジェクトを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> get_closure_object()
{
    <span class="cf">return</span> [=]{ <span class="cf">return</span> data ; } ;
}</code></pre></div>
<p>これを見ると、コピーキャプチャである[=]を使っているので、dataはクロージャーオブジェクト内にコピーされているように思える。しかし、ラムダ式は非staticデータメンバーをキャプチャーしてはいない。ラムダ式がキャプチャーしているのはthisポインターだ。上のコードと下のコードは同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> get_closure_object()
{
    <span class="cf">return</span> [<span class="kw">this</span>]{ <span class="cf">return</span> <span class="kw">this</span>-&gt;data ; } ;
}</code></pre></div>
<p>さて、main関数をもう一度見てみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// クロージャーオブジェクトを代入するための変数</span>
    <span class="bu">std::</span>function&lt; <span class="dt">int</span>() &gt; f ;

    {
        X x ; <span class="co">// xが構築される</span>
        f = x.get_closure_object() ;
        <span class="co">// xが破棄される</span>
    }

    <span class="co">// すでにxは破棄された</span>
    <span class="co">// return &amp;x-&gt;dataで破棄されたxを参照する</span>
    <span class="bu">std::</span>cout &lt;&lt; f() &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>なんと、すでに破棄されたオブジェクトへのリファレンスを参照してしまっている。これは未定義動作だ。</p>
<p>初期化ラムダキャプチャーを使えば、非staticデータメンバーもコピーキャプチャーできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> get_closure_object()
{
    <span class="cf">return</span> [data=data]{ <span class="cf">return</span> data ; } ;
}</code></pre></div>
<p>なお、ムーブキャプチャーは存在しない。ムーブというのは特殊なコピーなので初期化ラムダキャプチャーがあれば実現できるからだ</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> f()
{
    <span class="bu">std::</span>string str ;
    <span class="bu">std::</span>cin &gt;&gt; str ;
    <span class="co">// ムーブ</span>
    <span class="cf">return</span> [str = <span class="bu">std::</span>move(str)]{ <span class="cf">return</span> str ; } ;
}</code></pre></div>
<p>機能テストマクロは__cpp_init_captures, 値は201304。</p>
<h2 id="変数テンプレート">変数テンプレート</h2>
<p>変数テンプレートとは変数宣言をテンプレート宣言にできる機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T variable { } ;

<span class="dt">int</span> main()
{
    variable&lt;<span class="dt">int</span>&gt; = <span class="dv">42</span> ;
    variable&lt;<span class="dt">double</span>&gt; = <span class="fl">1.0</span> ;
}</code></pre></div>
<p>これだけではわからないだろうから、順を追って説明する。</p>
<p>C++ではクラスを宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> X
{
    <span class="dt">int</span> member ;
} ;</code></pre></div>
<p>C++ではクラスをテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">class</span> X
{
<span class="kw">public</span> :
    T member ;
} ;

<span class="dt">int</span> main()
{
    X&lt;<span class="dt">int</span>&gt; i ;
    i.member = <span class="dv">42</span> ; <span class="co">// int</span>

    X&lt;<span class="dt">double</span>&gt; d ;
    d.member = <span class="fl">1.0</span> ; <span class="co">// double</span>
}</code></pre></div>
<p>C++では関数を宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> f( <span class="dt">int</span> x )
{ <span class="cf">return</span> x ; }</code></pre></div>
<p>C++では関数をテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T f( T x )
{ <span class="cf">return</span> x ; }

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> i = f( <span class="dv">42</span> ) ; <span class="co">// int</span>
    <span class="kw">auto</span> d = f( <span class="fl">1.0</span> ) ; <span class="co">// double</span>
}</code></pre></div>
<p>C++11ではtypedef名を宣言するためにエイリアス宣言ができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="dt">int</span> ;</code></pre></div>
<p>C++11ではエイリアス宣言をテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">using</span> type = T ;

<span class="dt">int</span> main()
{
    type&lt;<span class="dt">int</span>&gt; i = <span class="dv">42</span> ; <span class="co">// int</span>
    type&lt;<span class="dt">double</span>&gt; d = <span class="fl">1.0</span> ; <span class="co">// double</span>
}</code></pre></div>
<p>そろそろパターンが見えてきたのではないだろうか。C++では一部の宣言はテンプレート宣言できるということだ。このパターンを踏まえて以下を考えてみよう。</p>
<p>C++では変数を宣言できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> variable{} ;</code></pre></div>
<p>C++14では変数宣言をテンプレート宣言できる。型テンプレートパラメーターは型として使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T variable { } ;

<span class="dt">int</span> main()
{
    variable&lt;<span class="dt">int</span>&gt; = <span class="dv">42</span> ;
    variable&lt;<span class="dt">double</span>&gt; = <span class="fl">1.0</span> ;
}</code></pre></div>
<p>変数テンプレートは名前通り変数宣言をテンプレート宣言できる機能だ。変数テンプレートはテンプレート宣言なので、名前空間スコープとクラススコープの中にしか書くことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// これはグローバル名前空間スコープという特別な名前空間スコープ</span>

<span class="kw">namespace</span> ns {
<span class="co">// 名前空間スコープ</span>
}

<span class="kw">class</span>
{
<span class="co">// クラススコープ</span>
} ;</code></pre></div>
<p>変数テンプレートの使い道は主に2つある。</p>
<h3 id="意味は同じだが型が違う定数">意味は同じだが型が違う定数</h3>
<p>プログラムでマジックナンバーを変数化しておくのは良い作法であるとされている。例えば円周率を3.14...などと書くよりもpiという変数名で扱ったほうがわかりやすい。変数化すると、円周率の値が後で変わった時にプログラムを変更するのも楽になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">double</span> pi = <span class="fl">3.1415926535</span> ;</code></pre></div>
<p>しかし、円周率表現する型が複数ある場合どうすればいいのか。よくあるのは名前を分ける方法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">float</span> pi_f = <span class="fl">3.1415</span> ;
<span class="kw">constexpr</span> <span class="dt">double</span> pi_d = <span class="fl">3.1415926535</span> ;
<span class="kw">constexpr</span> <span class="dt">int</span> pi_i = <span class="dv">3</span> ;
<span class="co">// 任意の精度の実数を表現できるクラスとする</span>
<span class="at">const</span> Real pi_r(<span class="st">&quot;3. 141592653589793238462643383279&quot;</span>) ;</code></pre></div>
<p>しかしこれは、使う側で型によって名前を買えなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 円の面積を計算する関数</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T calc_area( T r )
{
    <span class="co">// Tの型によって使うべき名前が変わる</span>
    <span class="cf">return</span> r * r * ??? ;
}</code></pre></div>
<p>関数テンプレートを使うという手がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">constexpr</span> T pi()
{
    <span class="cf">return</span> <span class="kw">static_cast</span>&lt;T&gt;(<span class="fl">3.1415926535</span>) ;
}

<span class="kw">template</span> &lt; &gt;
Real pi()
{
    <span class="cf">return</span> Real(<span class="st">&quot;3. 141592653589793238462643383279&quot;</span>) ;
}


<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T calc_area( T r )
{
    <span class="cf">return</span> r * r * pi&lt;T&gt;() ;
}</code></pre></div>
<p>しかし、この場合引数は何もないのに関数呼び出しのための()が必要だ。</p>
<p>変数テンプレートを使うと以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">constexpr</span> T pi = <span class="kw">static_cast</span>&lt;T&gt;(<span class="fl">3.1415926535</span>) ;

<span class="kw">template</span> &lt; &gt;
Real pi&lt;Real&gt;(<span class="st">&quot;3. 141592653589793238462643383279&quot;</span>) ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T calc_area( T r )
{
    <span class="cf">return</span> r * r * pi&lt;T&gt; ;
}</code></pre></div>
<h3 id="traitsのラッパー">traitsのラッパー</h3>
<p>値を返すtraitsで値を得るには::valueと書かなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>is_pointer&lt;<span class="dt">int</span>&gt;::value ;
<span class="bu">std::</span>is_same&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt;::value ;</code></pre></div>
<p>C++14ではstd::integral_constantにconstexpr operator boolが追加されたので、以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>is_pointer&lt;<span class="dt">int</span>&gt;{} ;
<span class="bu">std::</span>is_same&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt;{} ;</code></pre></div>
<p>しかしまだ面倒だ。変数テンプレートを使うとtraitsの記述が楽になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_pointer_v = <span class="bu">std::</span>is_pointer&lt;T&gt;::value ;
<span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> U &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_same_v = <span class="bu">std::</span>is_same&lt;T, U&gt;::value ;

is_pointer_v&lt;<span class="dt">int</span>&gt; ;
is_same_v&lt; <span class="dt">int</span>, <span class="dt">int</span> &gt; ;</code></pre></div>
<p>C++の標準ライブラリでは従来のtraitsライブラリを変数テンプレートでラップした_v版を用意している。</p>
<p>機能テストマクロは__cpp_variable_templates, 値は201304。</p>
<h2 id="constexpr関数の制限緩和">constexpr関数の制限緩和</h2>
<p>C++11で追加されたconstexpr関数はとても制限が強い。constexpr関数の本体には実質return文一つしか書けない。</p>
<p>C++14では、ほとんど何でも書けるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> f( <span class="dt">int</span> x )
{
    <span class="co">// 変数を宣言できる。</span>
    <span class="dt">int</span> sum = <span class="dv">0</span> ;

    <span class="co">// 繰り返し文を書ける。</span>
    <span class="cf">for</span> ( <span class="dt">int</span> i = <span class="dv">1</span> ; i &lt; x ; ++i )
    {
        <span class="co">// 変数を変更できる</span>
        sum += i ;
    }

    <span class="cf">return</span> sum ;
}</code></pre></div>
<p>機能テストマクロは__cpp_constexpr, 値は201304。</p>
<p>C++11のconstexpr関数に対応しているがC++14のconstexpr関数に対応していないC++実装では、__cpp_constexprマクロの値は200704になる。</p>
<h2 id="メンバー初期化子とアグリゲート初期化の組み合わせ">メンバー初期化子とアグリゲート初期化の組み合わせ</h2>
<p>C++14ではメンバー初期化子とアグリゲート初期化が組み合わせられるようになった。</p>
<p>メンバー初期化子とはクラスの非staticデータメンバーを=で初期化できるC++11の機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="co">// メンバー初期化子</span>
    <span class="dt">int</span> data = <span class="dv">123</span> ;
} ;</code></pre></div>
<p>アグリゲート初期化とはアグリゲートの条件を満たす型をリスト初期化で初期化できるC++11の機能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x, y, z ;
} ;

S s = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
<span class="co">// s.x == 1, s.y == 2, s.z == 3</span></code></pre></div>
<p>C++11ではメンバー初期化子を持つクラスはアグリゲート型の条件を満たさないのでアグリゲート初期化ができない。</p>
<p>C++14では、この制限が緩和された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x, y=<span class="dv">1</span>, z ;
} ;

S s1 = { <span class="dv">1</span> } ;
<span class="co">// s1.x == 1, s1.y == 1, s1.z == 0</span>

S s2{ <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
<span class="co">// s2.x == 1, s2.y == 2, s2.z == 3</span></code></pre></div>
<p>アグリゲート初期化で、メンバー初期化子をもつ非staticデータメンバーに対応する値がある場合はアグリゲート初期化が優先される。省略された場合はメンバー初期化子で初期化される。アグリゲート初期化でもメンバー初期化子でも明示的に初期化されていない非staticデータメンバーは空の初期化リストで初期化された場合と同じになる。</p>
<p>機能テストマクロは__cpp_aggregate_nsdmi, 値は201304。</p>
<h2 id="サイズ付き解放関数">サイズ付き解放関数</h2>
<p>C++14ではoperator deleteのオーバーロードに、解放すべきストレージのサイズを取得できるオーバーロードが追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>    ( <span class="dt">void</span> *, <span class="bu">std::</span>size_t ) <span class="kw">noexcept</span> ;
<span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span>[]  ( <span class="dt">void</span> *, <span class="bu">std::</span>size_t ) <span class="kw">noexcept</span> ;</code></pre></div>
<p>第二引数はstd::size_t型で、第一引数で指定されたポインターが指す解放すべきストレージのサイズが与えられる。</p>
<p>例えば以下のように使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * <span class="kw">operator</span> <span class="kw">new</span> ( <span class="bu">std::</span>size_t size )
{
    <span class="dt">void</span> * ptr =  <span class="bu">std::</span>malloc( size ) ;

    <span class="cf">if</span> ( ptr == <span class="kw">nullptr</span> )
        <span class="cf">throw</span> <span class="bu">std::</span>bad_alloc() ;

    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;allocated storage of size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    <span class="cf">return</span> ptr ;
}

<span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span> ( <span class="dt">void</span> * ptr, <span class="bu">std::</span>size_t size ) <span class="kw">noexcept</span>
{
    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;deallocated storage of size: &quot;</span> &lt;&lt; size &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    <span class="bu">std::</span>free( ptr ) ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> u1 = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">0</span>) ;
    <span class="kw">auto</span> u2 = <span class="bu">std::</span>make_unique&lt;<span class="dt">double</span>&gt;(<span class="fl">0.0</span>) ;
}</code></pre></div>
<p>機能テストマクロは__cpp_sized_deallocation, 値は201309。</p>
<h1 id="c17のコア言語の新機能">C++17のコア言語の新機能</h1>
<p>C++14の新機能のおさらいが終わったところで、いよいよC++17のコア言語の新機能を解説していく。</p>
<p>C++17のコア言語の新機能には、C++11ほどの大きなものはない。</p>
<h2 id="トライグラフの廃止">トライグラフの廃止</h2>
<p>C++17ではトライグラフが廃止された。</p>
<p>トライグラフを知らない読者はこの変更を気にする必要はない。トライグラフを知っている読者はなおさら気にする必要はない。</p>
<h2 id="進数浮動小数点数リテラル">16進数浮動小数点数リテラル</h2>
<p>C++17では浮動小数点数リテラルに16進数を使うことができるようになった。</p>
<p>16進数浮動小数点数リテラルは、プレフィクス0xに続いて仮数部を16進数(0123456789abcdefABCDEF)で書き、pもしくはPに続けて指数部を10進数で書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> d1 = <span class="er">0x1p0</span> ; <span class="co">// 1</span>
<span class="dt">double</span> d2 = <span class="bn">0x1</span>.<span class="er">0p0</span> ; <span class="co">// 1</span>
<span class="dt">double</span> d3 = <span class="er">0x10p0</span> ; <span class="co">// 16</span>
<span class="dt">double</span> d4 = <span class="er">0xabcp0</span> ; <span class="co">// 2748</span></code></pre></div>
<p>指数部はeではなくpかPを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">double</span> d1 = <span class="er">0x1p0</span> ;
<span class="dt">double</span> d2 = <span class="er">0x1P0</span> ;</code></pre></div>
<p>16進数浮動小数点数リテラルでは、指数部を省略できない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a = <span class="bn">0x1</span> ; <span class="co">// 整数リテラル</span>
<span class="bn">0x1</span><span class="fl">.0</span> ; <span class="co">// エラー、指数部がない</span></code></pre></div>
<p>指数部は10進数で記述する。16進数浮動小数点数リテラルの仮数部は指数部の2の階乗で乗算される。</p>
<p>0xNpM</p>
<p>という浮動小数点数リテラルの値は</p>
<p><span class="math inline">\(N \times 2^M\)</span></p>
<p>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="er">0x1p0</span> ; <span class="co">// 1</span>
<span class="er">0x1p1</span> ; <span class="co">// 2</span>
<span class="er">0x1p2</span> ; <span class="co">// 4</span>
<span class="er">0x10p0</span> ; <span class="co">// 16</span>
<span class="er">0x10p1</span> ; <span class="co">// 32</span>
<span class="er">0x1p</span><span class="dv">-1</span> ; <span class="co">// 0.5</span>
<span class="er">0x1p</span><span class="dv">-2</span> ; <span class="co">// 0.25</span></code></pre></div>
<p>16進数浮動小数点数リテラルには浮動小数点数サフィックスを記述できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> a = <span class="er">0x1p0f</span> ; <span class="co">// float</span>
<span class="kw">auto</span> b = <span class="er">0x1p0l</span> ; <span class="co">// long double</span></code></pre></div>
<p>16進数浮動小数点数リテラルは、浮動小数点数が表現方法の詳細を知っている環境(例えばIEEE-754)で、正確な浮動小数点数の表現が記述できるようになる。</p>
<p>機能テストマクロは__cpp_hex_float, 値は201603。</p>
<h2 id="utf-8文字リテラル">UTF-8文字リテラル</h2>
<p>C++17ではUTF-8文字リテラルが追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> c = u8<span class="st">&#39;a&#39;</span> ;</code></pre></div>
<p>UTF-8文字リテラルは文字リテラルにプレフィクスu8をつける。UTF-8文字リテラルはUTF-8のコード単位一つで表現できる文字を扱うことができる。UCSの規格としては、C0制御文字と基本ラテン文字Unicodeブロックが該当する。UTF-8文字リテラルに書かれた文字が複数のUTF-8コード単位を必要とする場合はエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// エラー</span>
<span class="co">// U+3042はUTF-8は0xE3, 0x81, 0x82という3つのコード単位で表現する必要があるため</span>
u8<span class="st">&#39;あ&#39;</span> ;</code></pre></div>
<p>機能テストマクロはない。</p>
<h2 id="関数型としての例外指定">関数型としての例外指定</h2>
<p>C++17では例外指定が関数型に組み込まれた。</p>
<p>例外指定とはnoexceptのことだ。noexceptとnoexcept(true)が指定された関数は例外を外に投げない。</p>
<p>C++14ではこの例外指定は型システムに入っていなかった。そのため、無例外指定のついた関数へのポインター型は型システムで無例外を保証することができなかった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// C++14のコード</span>
<span class="dt">void</span> f()
{
    <span class="cf">throw</span> <span class="dv">0</span> ; 
}

<span class="dt">int</span> main()
{
    <span class="co">// 無例外指定のついたポインター</span>
    <span class="dt">void</span> (*p)() <span class="kw">noexcept</span> = &amp;f ;

    <span class="co">// 無例外指定があるにもかかわらず例外を投げる</span>
    p() ;
}</code></pre></div>
<p>C++17では例外指定が型システムに組み込まれた。例外指定のある関数型を例外指定のない関数へのポインター型に変換することはできる。逆はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 型はvoid()</span>
<span class="dt">void</span> f() { }
<span class="co">// 型はvoid() noexcept</span>
<span class="dt">void</span> g() <span class="kw">noexcept</span> { }

<span class="co">// OK</span>
<span class="co">// p1, &amp;fは例外指定のない関数へのポインター型</span>
<span class="dt">void</span> (*p1)() = &amp;f ;
<span class="co">// OK</span>
<span class="co">// 例外指定のある関数へのポインター型&amp;gを例外指定のない関数へのポインター型p2に変換できる</span>
<span class="dt">void</span> (*p2)() = &amp;g ; <span class="co">// OK</span>

<span class="co">// エラー</span>
<span class="co">// 例外指定のない関数へのポインター型&amp;fは例外指定のある関数へのポインター型p3に変換できない</span>
<span class="dt">void</span> (*p3)() <span class="kw">noexcept</span> = &amp;f ;

<span class="co">// OK</span>
<span class="co">// p4, &amp;fは例外指定のある関数へのポインター型</span>
<span class="dt">void</span> (*p4)() noexdept = &amp;f ;</code></pre></div>
<p>機能テストマクロは__cpp_noexcept_function_type, 値は201510。</p>
<h2 id="fold式">fold式</h2>
<p>C++17にはfold式が入った。foldは元は数学の概念で畳み込みとも呼ばれている。</p>
<p>C++におけるfold式とはパラメーターパックの中身に二項演算子を適用するための式だ。</p>
<p>今、可変長テンプレートを使って受け取った値をすべて加算した合計を返す関数sumを書きたいとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( T x, Types ... args ) ;

<span class="dt">int</span> main()
{
    <span class="dt">int</span> result = sum(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>) ; <span class="co">// 45</span>
}</code></pre></div>
<p>このような関数テンプレートsumは以下のように実装することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">auto</span> sum( T x )
{
    <span class="cf">return</span> x ;
}

<span class="kw">template</span> &lt; <span class="kw">typename</span> T, <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( T x, Types ... args )
{
    <span class="cf">return</span> x + sum( args... )  ;
}</code></pre></div>
<p>sum(x, args)は1番目の引数をxで、残りをパラメーターパックargsで受け取る。そして、x + sum( args ... )を返す。すると、sum( args ... )はまたsum(x, args)に渡されて、1番目の引数、つまり最初から見て2番目の引数がxに入り、またsumが呼ばれる。このような再帰的な処理を繰り返していく。</p>
<p>そして、引数がひとつだけになると、可変長テンプレートではないsumが呼ばれる。これは重要だ。なぜならば可変長テンプレートは0個の引数を取ることができるので、そのまま可変長テンプレート版のsumが呼ばれてしまうと、次のsumの呼び出しができずにエラーとなる。これを回避するために、また再起の終了条件のために、引数がひとつのsumのオーバーロード関数を書いておく。</p>
<p>可変長テンプレートでは任意個の引数に対応するために、このような再帰的なコードが必須になる。</p>
<p>しかし、ここで実現したいこととはN個あるパラメーターパックargsの中身に対して、仮にN番目をargs#Nとする表記を使うと、args#0 + args#1 + ... + args#Nのような展開をしたいだけだ。C++17のfold式はパラメーターパックに対して二項演算子を適用する展開を行う機能だ。</p>
<p>fold式を使うとsumは以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( Types ... args )
{
    <span class="cf">return</span> ( ... + args )  ;
}</code></pre></div>
<p>( ... + args )は、args#0 + args#1 + ... + args#Nのように展開される。</p>
<p>fold式には、単項fold式と二項fold式がある。そして、演算子の結合順序に合わせて左foldと右foldがある。</p>
<p>fold式は必ず括弧で囲まなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> sum( Types ... args )
{
    <span class="co">// fold式</span>
    ( ... + args )  ;
    <span class="co">// エラー、括弧がない</span>
    ... + args ;
}</code></pre></div>
<p>単項fold式の文法は以下のいずれかになる。</p>
<pre><code>単項右fold
( cast-expression fold-operator ... )
単項左fold
( ... fold-operator cast-expression )</code></pre>
<p>例</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="dt">void</span> f( Types ... args )
{
    <span class="co">// 単項左fold</span>
    ( ... + args )  ;
    <span class="co">// 単項右fold</span>
    ( args + ... ) ;
}</code></pre></div>
<p>cast-expressionには未展開のパラメーターパックが入っていなければならない。</p>
<p>例：</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
T f( T x ) { <span class="cf">return</span> x ; }

<span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">auto</span> g( Types ... args )
{
    <span class="co">// f(args#0) + f(args#1) + ... + f(args#N)</span>
    <span class="cf">return</span> ( ... + f(args) )  ;
}</code></pre></div>
<p>これはf(args)というパターンが展開される。</p>
<p>fold-operatorにはいかのいずれかの二項演算子を使うことができる。</p>
<pre><code>+   -   *   /   %   ^   &amp;   |   &lt;&lt;  &gt;&gt;
+=  -=  *=  /=  %=  ^=  &amp;=  |=  &lt;&lt;= &gt;&gt;+ =
==  !=  &lt;   &gt;   &lt;=  &gt;=  &amp;&amp;  ||  ,   .*  -&gt;*</code></pre>
<p>fold式には左foldと右foldがある。</p>
<p>左fold式の ( ... op pack )では、展開結果は( (( pack#0 op pack#1) op pack#2) ... op pack#N )となる。右fold式の( pack op ... )では、展開結果は( pack#0 op (pack#1 op ( pack#2 op (... op pack#N))))となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="dt">void</span> sum( Types ... args )
{
    <span class="co">// 左fold</span>
    <span class="co">// ((((1+2)+3)+4)+5)</span>
    <span class="kw">auto</span> left = ( ... + args ) ;
    <span class="co">// 右fold</span>
    <span class="co">// (1+(2+(3+(4+5))))</span>
    <span class="kw">auto</span> right = ( args + ... ) ;
}

<span class="dt">int</span> main()
{
    sum(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>) ;
}</code></pre></div>
<p>浮動小数点数のような交換法則を満たさない型にfold式を適用する際には注意が必要だ。</p>
<p>二項fold式の文法は以下のいずれかになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">( cast-expression fold-<span class="kw">operator</span> ... fold-<span class="kw">operator</span> cast-expression</code></pre></div>
<p>左右のcast-expressionのどちらか片方だけに未展開のパラメーターパックが入っていなければならない。2つのfold-operatorは同じ演算子でなければならない。</p>
<p>( e1 op1 ... op2 e2 )という二項fold式があったとき、e1にパラメーターパックがある場合は二項右fold式、e2にパラメーターパックがある場合は二項左fold式になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="dt">void</span> sum( Types ... args )
{
    <span class="co">// 左fold</span>
    <span class="co">// (((((0+1)+2)+3)+4)+5)</span>
    <span class="kw">auto</span> left = ( <span class="dv">0</span> + ... + args ) ;
    <span class="co">// 右fold</span>
    <span class="co">// (0+(1+(2+(3+(4+5)))))</span>
    <span class="kw">auto</span> right = ( args + ... + <span class="dv">0</span> ) ;
}

<span class="dt">int</span> main()
{
    sum(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>) ;
}</code></pre></div>
<p>fold式はパラメーターパックのそれぞれに二項演算子を適用したい時にわざわざ複雑な再帰的テンプレートを書かずにすむ方法を提供してくれる。</p>
<p>機能テストマクロは__cpp_fold_expressions, 値は201603。</p>
<h2 id="ラムダ式でthisのコピーキャプチャー">ラムダ式で*thisのコピーキャプチャー</h2>
<p>C++17ではラムダ式で*thisをコピーキャプチャーできるようになった。*thisをコピーキャプチャーするには、ラムダキャプチャーに*thisと書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> data = <span class="dv">42</span> ;
   <span class="kw">auto</span> get()
   {
       <span class="cf">return</span> [*<span class="kw">this</span>]() { <span class="cf">return</span> <span class="kw">this</span>-&gt;data ; } ;
   }
} ;

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>function &lt;<span class="dt">int</span> () &gt; f ;
    {
        X x ;
        f = x.get() ;
    }<span class="co">// xの寿命はここまで</span>
    
    <span class="co">// コピーされているので問題ない</span>
    <span class="dt">int</span> data = f() ;
}</code></pre></div>
<p>コピーキャプチャーする*thisはlambda式が書かれた場所の*thisだ。</p>
<p>また、以下のようなコードで挙動の違いをみるとわかりやすい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> data = <span class="dv">0</span> ;
   <span class="dt">void</span> f()
   {
        <span class="co">// thisはポインターのキャプチャー</span>
        <span class="co">// dataはthisポインターを</span>
        [<span class="kw">this</span>]{ data = <span class="dv">1</span> ; }() ;

        <span class="co">// this-&gt;dataは1</span>

        <span class="co">// エラー、*thisはコピーされている</span>
        <span class="co">// クロージャーオブジェクトのコピーキャプチャされた変数はデフォルトで変更できない</span>
        [*<span class="kw">this</span>]{ data = <span class="dv">2</span> ; } () ;

        <span class="co">// OK、mutableを使っている</span>

        [*<span class="kw">this</span>]() <span class="at">mutable</span> { data = <span class="dv">2</span> ; } () ;

        <span class="co">// this-&gt;dataは1</span>
        <span class="co">// 変更されたのはコピーされたクロージャーオブジェクト内の*this        </span>
   }
} ;</code></pre></div>
<p>最初のラムダ式で生成されるクロージャーオブジェクトは以下のようなものだ。 <sub>~</sub>c++ class closure_object { X * this_ptr ;</p>
<p>public : closure_object( X * this ) : this(this) { }</p>
<pre><code>void operator () const
{
    this_ptr-&gt;data = 1 ;
}</code></pre>
<p>} ; <sub>~</sub></p>
<p>二番目のラムダ式では以下のようなクロージャーオブジェクトが生成される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> closure_object
{
    X this_obj ;
    X <span class="at">const</span> * this_ptr = &amp;this_obj ;

<span class="kw">public</span> :
    closure_object( X <span class="at">const</span> &amp; this_obj )
        : this_obj(this_obj) { }

    <span class="dt">void</span> <span class="kw">operator</span> () <span class="at">const</span>
    {
        this_ptr-&gt;data = <span class="dv">1</span> ;
    }
} ;</code></pre></div>
<p>三番目のラムダ式では以下のようなクロージャーオブジェクトが生成される。</p>
<p>これはC++の文法に従っていないのでやや苦しいコード例だが、コピーキャプチャーされた値を変更しようとしているためエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> closure_object
{
    X this_obj ;
    X * this_ptr = &amp;this_obj ;

<span class="kw">public</span> :
    closure_object( X <span class="at">const</span> &amp; this_obj )
        : this_obj(this_obj) { }

    <span class="dt">void</span> <span class="kw">operator</span> ()
    {
        this_ptr-&gt;data = <span class="dv">2</span> ;
    }
} ;</code></pre></div>
<p>ラムダ式にmutableが付いているのでコピーキャプチャーされた値も変更できる。</p>
<p>*thisをコピーキャプチャーした場合、thisキーワードはコピーされたオブジェクトへのポインターになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> data = <span class="dv">42</span> ;
   <span class="dt">void</span> f()
   {
        <span class="co">// thisはこのメンバー関数fを呼び出したオブジェクトへのアドレス</span>
        <span class="bu">std::</span>printf(<span class="st">&quot;%p</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">this</span> ) ;

        <span class="co">// thisはコピーされた別のオブジェクトへのアドレス</span>
        [*<span class="kw">this</span>](){  <span class="bu">std::</span>printf(<span class="st">&quot;%p</span><span class="sc">\n</span><span class="st">&quot;</span>, <span class="kw">this</span>) ;  }() ;
   }
} ;

<span class="dt">int</span> main()
{
    X x ;
    x.f() ;
}</code></pre></div>
<p>この場合、出力される2つのポインターの値は異なる。</p>
<p>ラムダ式での*thisのコピーキャプチャーは名前通り*thisのコピーキャプチャーを提供する提案だ。同等の機能は初期化キャプチャーでも可能だが、表記が冗長で間違いの元だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> data ;

    <span class="kw">auto</span> f()
    {
        <span class="cf">return</span> [ tmp = *<span class="kw">this</span> ] { <span class="cf">return</span> <span class="kw">this</span>-&gt;data ; } ;
    }
} ;</code></pre></div>
<p>機能テストマクロは__cpp_capture_star_this, 値は201603。</p>
<h2 id="constexprラムダ式">constexprラムダ式</h2>
<p>C++17ではラムダ式がconstexprになった。より正確に説明すると、ラムダ式のクロージャーオブジェクトのoperator ()は条件を満たす場合constexprになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []{ <span class="cf">return</span> <span class="dv">42</span> ; } ;

    <span class="kw">constexpr</span> <span class="dt">int</span> value = f() ; <span class="co">// OK</span>
}</code></pre></div>
<p>constexprの条件を満たす　ラムダ式はコンパイル時定数を必要とする場所で使うことができる。例えばconstexpr変数や配列の添字やstatic_assertなどだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> f = []{ <span class="cf">return</span> <span class="dv">42</span> ; } ;

    <span class="dt">int</span> a[f()] ;
    <span class="kw">static_assert</span>( f() == <span class="dv">42</span> ) ;
    <span class="bu">std::</span>array&lt;<span class="dt">int</span>, f()&gt; b ;
}</code></pre></div>
<p>constexprの条件を満たすのであれば、キャプチャーもできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a = <span class="dv">0</span> ; <span class="co">// 実行時の値</span>
    <span class="kw">constexpr</span> <span class="dt">int</span> b = <span class="dv">0</span> ; <span class="co">// コンパイル時定数 </span>

    <span class="kw">auto</span> f = [=]{ <span class="cf">return</span> a ; } ;
    <span class="kw">auto</span> g = [=]{ <span class="cf">return</span> b ; } ;

    <span class="co">// エラー、constexprの条件を満たさない</span>
    <span class="kw">constexpr</span> <span class="dt">int</span> c = f() ;

    <span class="co">// Ok、constexprの条件を満たす</span>
    <span class="kw">constexpr</span> <span class="dt">int</span> d = f() ;
}</code></pre></div>
<p>機能テストマクロは__cpp_constexpr, 値は201603。</p>
<p>__cpp_constexprマクロの値は、C++11の時点で200704、C++14の時点で201304だ。</p>
<h2 id="文字列なしstatic_assert">文字列なしstatic_assert</h2>
<p>C++17ではstatic_assertに文字列リテラルをとらないものが追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">static_assert</span>( <span class="kw">true</span> ) ;</code></pre></div>
<p>C++11で追加されたstatic_asserには、文字列リテラルが必須だった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">static_assert</span>( <span class="kw">true</span>, <span class="st">&quot;this shall not be asserted.&quot;</span>) ;</code></pre></div>
<p>特に文字列を指定する必要がない場合もあるので、文字列リテラルを取らないstatic_assertが追加された。</p>
<p>機能テストマクロは__cpp_static_assert, 値は201411。</p>
<p>C++11の時点で__cpp_static_assertの値は200410。</p>
<h2 id="ネストされた名前空間定義">ネストされた名前空間定義</h2>
<p>C++17ではネストされた名前空間の定義を楽に書ける。</p>
<p>ネストされた名前空間とは、A::B::Cのように名前空間の中に名前空間が入っている名前空間のことだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A {
    <span class="kw">namespace</span> B {
        <span class="kw">namespace</span> C {
        <span class="co">// ...</span>
        }
    }
} </code></pre></div>
<p>C++17では、上記のコードと同じことを以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> A::B::C {
<span class="co">// ...</span>
}</code></pre></div>
<p>機能テストマクロは__cpp_nested_namespace­_definitions, 値は201411。</p>
<h2 id="fallthrough属性">[[fallthrough]]属性</h2>
<p>[[fallthrough]]属性はswitch文の中のcaseラベルを突き抜けるというヒントを出すのに使える。</p>
<p>switch文では対応するcaseラベルに処理が移る。通常、以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">int</span> x )
{
    swtich ( x )
    {
    <span class="cf">case</span> <span class="dv">0</span> :
        <span class="co">// 処理0</span>
        <span class="cf">break</span> ;
    <span class="cf">case</span> <span class="dv">1</span> :
        <span class="co">// 処理1</span>
        <span class="cf">break</span> ;
    <span class="cf">case</span> <span class="dv">2</span> :
        <span class="co">// 処理2</span>
        <span class="cf">break</span> ;
    <span class="cf">default</span> :
        <span class="co">// xがいずれでもない場合の処理</span>
        <span class="cf">break</span> ;
    }
}</code></pre></div>
<p>この例を以下のように書くと</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">case</span> <span class="dv">1</span> :
    <span class="co">// 処理1</span>
<span class="cf">case</span> <span class="dv">2</span> :
    <span class="co">// 処理2</span>
    <span class="cf">break</span> ;</code></pre></div>
<p>xが1の時は処理1を実行した後に、処理2も実行される。switch文を書くときはこのような誤りを書いてしまうことがある。そのため、賢いC++コンパイラーはswitch文のcaseラベルでbreak文やreturn文などで処理が終わらず、次のcaseラベルやdefaultラベルに処理に突き抜けるコードを発見すると、警告メッセージを出す。</p>
<p>しかし、プログラマーの意図がまさに突き抜けて処理して欲しい場合、警告メッセージは誤った警告となってしまう。そのような警告メッセージを抑制するため、またコード中に処理が突き抜けるという意図をわかりやすく記述するために、[[fallthrough]]属性が追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">case</span> <span class="dv">1</span> :
    <span class="co">// 処理1</span>
    [[<span class="at">fallthrough</span>]]
<span class="cf">case</span> <span class="dv">2</span> :
    <span class="co">// 処理2</span>
    <span class="cf">break</span> ;</code></pre></div>
<p>[[fallthrough]]属性を書くと、C++コンパイラーは処理がその先に突き抜けることがわかるので、誤った警告メッセージを抑制できる。また、他人がコードを読むときに意図が明らかになる。</p>
<p>機能テストマクロは__has_cpp_attribute(fallthrough), 値は201603。</p>
<h2 id="nodiscard属性">[[nodiscard]]属性</h2>
<p>[[nodiscard]]属性は関数の戻り値が無視されてほしくない時に使うことができる。[[nodiscard]]属性が付与された関数の戻り値を無視すると警告メッセージが表示される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[<span class="at">nodiscard</span>]] <span class="dt">int</span> f()
{
    <span class="cf">return</span> <span class="dv">0</span> ;
}

<span class="dt">void</span> g( <span class="dt">int</span> ) { }

<span class="dt">int</span> main()
{
    <span class="co">// エラー、戻り値が無視されている</span>
    f() ;

    <span class="co">// OK、戻り値は無視されていない。</span>
    <span class="dt">int</span> result = f() ;
    g( f ) ;
    f() + <span class="dv">1</span> ;
    (<span class="dt">void</span>) f() ;
}</code></pre></div>
<p>戻り値を無視する、というのは万能ではない。上の例でも、意味的には戻り値は無視されていると言えるが、コンパイラーはこの場合に戻り値が無視されているとは考えない。</p>
<p>[[nodiscard]]の目的は、戻り値を無視してほしくない関数をユーザーが利用した時の初歩的な間違いを防ぐためにある。void型にキャストするような意図的な戻り値の無視まで防ぐようには作られていない。</p>
<p>[[nodiscard]]属性を使うべき関数は、戻り値を無視してほしくない関数だ。どのような関数が戻り値を無視してほしくないかというと大きく2つある。</p>
<p>戻り値をエラーなどのユーザーが確認しなければならない情報の通知に使う関数。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">enum</span> <span class="kw">struct</span> error_code
{
    no_error, some_operations_failed,  serious_error
} ;

<span class="co">// 失敗するかもしれない処理</span>
<span class="dt">int</span> do_something_that_may_fail()
{
    <span class="co">// 処理</span>

    <span class="cf">if</span> ( is_error_condition() )
        <span class="cf">return</span> error_code::serious_error ;

    <span class="co">// 処理</span>

    <span class="cf">return</span> error_code::no_error ;
}

<span class="co">// エラーが一切発生しなかった時の処理</span>
<span class="dt">int</span> do_something_on_no_error() ;

<span class="dt">int</span> main()
{
    <span class="co">// エラーを確認していない</span>
    do_soemthing() ;

    <span class="co">// エラーがない前提で次の処理をしようとする</span>
    do_something_on_no_error() ;
}</code></pre></div>
<p>関数に[[nodiscard]]属性を付与しておけば、このようなユーザー側の初歩的なエラー確認の欠如に警告メッセージを出せる。</p>
<p>[[nodiscard]]属性は、クラスとenumにも付与することができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> [[<span class="at">nodiscard</span>]] X { } ;
<span class="kw">enum</span> <span class="kw">class</span> [[<span class="at">nodiscard</span>]] Y { } ;</code></pre></div>
<p>[[nodiscard]]が付与されたクラスかenumが戻り値の型である関数は[[nodiscard]]が付与された扱いとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> [[<span class="at">nodiscard</span>]] X { } ;

X f() { <span class="cf">return</span> X{} ; } 

<span class="dt">int</span> main()
{
    <span class="co">// 警告、戻り値が無視されている</span>
    f() ;
}</code></pre></div>
<p>機能テストマクロは__has_cpp_attribute(nodiscard), 値は201603。</p>
<h2 id="maybe_unused属性">[[maybe_unused]]属性</h2>
<p>[[maybe_unused]]属性は名前やエンティティが意図的に使われないことを示すのに使える。</p>
<p>現実のC++のコードでは、宣言されているのにソースコードだけを考慮するとどこからも使われていないように見える名前やエンティティが存在する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> do_something( <span class="dt">int</span> *, <span class="dt">int</span> * ) ;

<span class="dt">void</span> f()
{
    <span class="dt">int</span> x[<span class="dv">5</span>] ;
    <span class="dt">char</span> reserved[<span class="dv">1024</span>] = { } ;
    <span class="dt">int</span> y[<span class="dv">5</span>] ;

    do_something( x, y ) ;
}</code></pre></div>
<p>ここではreservedという名前はどこからも使われていない。一見すると不必要な名前に見える。優秀なC++コンパイラーはこのようなどこからも使われていない名前に対して「どこからも使われていない」という警告メッセージを出す。</p>
<p>しかし、コンパイラーから見えているソースコードがプログラムの全てではない。様々な理由でreservedのような一見使われていない変数が必要になる。</p>
<p>例えば、reservedはスタック破壊を検出するための領域かもしれない。プログラムはC++以外の言語で書かれたコードとリンクしていて、そこで使われるのかもしれない。あるいはOSや外部デバイスが読み書きするメモリとして確保しているのかもしれない。</p>
<p>どのような理由にせよ、名前やエンティティが一見使われていないように見えるが存在が必要であるという意味を表すのに、[[maybe_unused]]属性を使うことができる。これにより、C++コンパイラーの「未使用の名前」という警告メッセージを抑制できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[<span class="at">maybe_unused</span>]] <span class="dt">char</span> reserved[<span class="dv">1024</span>] ;</code></pre></div>
<p>[[maybe_unused]]属性を適用できる名前とエンティティの宣言は、クラス、typedef名、変数、非staticデータメンバー、関数、enum、enumeratorだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// クラス</span>
<span class="kw">class</span> [[<span class="at">maybe_unused</span>]] class_name
{
<span class="co">// 非staticデータメンバー</span>
    [[<span class="at">maybe_unused</span>]] <span class="dt">int</span> non_static_data_member ;

} ;

<span class="co">// typedef名</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">maybe_unused</span>]] <span class="kw">typedef</span> <span class="dt">int</span> typedef_name1 ;
<span class="kw">typedef</span> <span class="dt">int</span> typedef_name2 [[<span class="at">maybe_unused</span>]] ;

<span class="co">// エイリアス宣言によるtypedef名</span>
<span class="kw">using</span> typedef_name3 [[<span class="at">maybe_unused</span>]] = <span class="dt">int</span> ;

<span class="co">// 変数</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">maybe_unused</span>]] <span class="dt">int</span> variable_name1{};
<span class="dt">int</span> variable_name2 [[<span class="at">maybe_unused</span>]] { } ;

<span class="co">// 関数</span>
<span class="co">// メンバー関数も同じ文法</span>
<span class="co">// どちらでもよい</span>
[[<span class="at">maybe_unused</span>]] <span class="dt">void</span> function_name1() { }
<span class="dt">void</span> function_name2 [[<span class="at">maybe_unused</span>]] () { }

<span class="kw">enum</span> [[<span class="at">maybe_unused</span>]] enum_name
{
<span class="co">// enumerator</span>
    enumerator_name [[<span class="at">maybe_unused</span>]] = <span class="dv">0</span>
} ;</code></pre></div>
<p>機能テストマクロは__has_cpp_attribute(maybe_unused), 値は201603</p>
<h2 id="演算子のオペランドの評価順序の固定">演算子のオペランドの評価順序の固定</h2>
<p>C++17では演算子のオペランドの評価順序が固定された。</p>
<p>以下の式は、a, b, c, dの順番に評価されることが規格上保証される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">a.b
a-&gt;b
a-&gt;*b
a(b1,b2,b3)
b <span class="er">@</span>= a
a[b]
a &lt;&lt; b
a &gt;&gt; b</code></pre></div>
<p>つまり、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span>* f() ;
<span class="dt">int</span> g() ;

<span class="dt">int</span> main()
{
   f()[g()] ; 
}</code></pre></div>
<p>と書いた場合、関数fがまず先に呼び出されて、次に関数gが呼び出されることが保証される。</p>
<p>関数呼び出しの実引数のオペランドb1, b2, b3の評価順序は未規定のままだ。</p>
<p>これにより、既存の未定義の挙動となっていたコードの挙動が定まる。</p>
<h2 id="constexpr-if文-コンパイル時条件分岐">constexpr if文 : コンパイル時条件分岐</h2>
<p>constexpr if文はコンパイル時の条件分岐ができる機能だ。</p>
<p>constexpr if文は、通常のif文をif constexprで置き換える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// if文</span>
<span class="cf">if</span> ( expression )
    statement ;

<span class="co">// constexpr if文</span>
<span class="cf">if</span> <span class="kw">constexpr</span> ( expression )
    statement ;</code></pre></div>
<p>constexpr if文という名前だが、実際に記述するときはif constexprだ。</p>
<p>コンパイル時の条件分岐とは何を意味するのか。以下はconstexpr ifが<strong>行わないもの</strong>の一覧だ。</p>
<ul>
<li>最適化</li>
<li>非テンプレートコードにおける挙動の変化</li>
</ul>
<p>コンパイル時の条件分岐の機能を理解するには、まずC++の既存の条件分岐について理解する必要がある。</p>
<h3 id="実行時の条件分岐">実行時の条件分岐</h3>
<p>通常の実行時の条件分岐は、実行時の値を取り、実行に条件分岐を行う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    <span class="cf">if</span> ( runtime_value )
        do_true_thing() ;
    <span class="cf">else</span>
        do_false_thing() ;
}</code></pre></div>
<p>この場合、runtime_valueがtrueの場合は関数do_true_thingが呼ばれ、falseの場合は関数do_false_thingが呼ばれる。</p>
<p>実行時の条件分岐の条件には、コンパイル時定数を指定できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( <span class="kw">true</span> )
    do_true_thing() ;
<span class="cf">else</span>
    do_false_thing() ;</code></pre></div>
<p>この場合、賢いコンパイラーは以下のように処理を最適化するかもしれない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">do_true_thing() ;</code></pre></div>
<p>なぜならば、条件は常にtrueだからだ。このような最適化は実行時の条件分岐でもコンパイル時に行える。コンパイル時の条件分岐はこのような最適化が目的ではない。</p>
<p>もう一度コード例に戻ろう。こんどは完全なコードをみてみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// do_true_thingの宣言</span>
<span class="dt">void</span> do_true_thing() ;

<span class="co">// do_false_thingの宣言は存在しない</span>

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    <span class="cf">if</span> ( <span class="kw">true</span> )
        do_true_thing() ;
    <span class="cf">else</span>
        do_false_thing() ; <span class="co">// エラー</span>
}</code></pre></div>
<p>このコードはエラーになる。その理由は、do_false_thingという名前が宣言されていないからだ。C++コンパイラーは、コンパイル時にコードを以下の形に変形することで最適化することはできるが、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> do_true_thing() ;

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    do_true_thing() ;
}</code></pre></div>
<p>最適化の結果失われたものも、依然としてコンパイル時にコードとして検証はされる。コードとして検証されるということは、コードとして誤りがあればエラーとなる。名前do_false_thingは宣言されていないのでエラーとなる。</p>
<h3 id="プリプロセス時の条件分岐">プリプロセス時の条件分岐</h3>
<p>C++がC言語から受け継いだCプリプロセッサーには、プリプロセス時の条件分岐の機能がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// do_true_thingの宣言</span>
<span class="dt">void</span> do_true_thing() ;

<span class="co">// do_false_thingの宣言は存在しない</span>

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{

<span class="pp">#if true</span>
    do_true_thing() ;
<span class="pp">#else</span>
<span class="co">    do_false_thing() ;</span>
<span class="pp">#endif</span>
}</code></pre></div>
<p>このコードは、プリプロセスの結果、以下のように変換される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> do_true_thing() ;

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    do_true_thing() ;
}</code></pre></div>
<p>この結果、プリプロセス時の条件分岐では、選択されない分岐はコンパイルされないので、コンパイルエラーになるコードも書くことができる。</p>
<p>プリプロセス時の条件分岐は、条件が整数とかbool型のリテラルか、リテラルに比較演算子を適用した結果ではうまくいく、しかし、プリプロセス時とはコンパイル時ではないので、コンパイル時計算はできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">int</span> f()
{
    <span class="cf">return</span> <span class="dv">1</span> ;
}

<span class="dt">void</span> do_true_thing() ;

<span class="dt">int</span> main()
{
<span class="co">// エラー</span>
<span class="co">// 名前fはプリプロセッサーマクロではない。</span>
<span class="pp"># if f()</span>
    do_true_thing() ;
<span class="pp">#else</span>
    do_false_thing() ;
<span class="pp">#endif</span>
}</code></pre></div>
<h3 id="コンパイル時の条件分岐">コンパイル時の条件分岐</h3>
<p>コンパイル時の条件分岐とは、分岐の条件にコンパイル時計算の結果を使い、かつ、選択されない分岐にコンパイルエラーが含まれていても、使われないのでコンパイルエラーにはならない条件分岐のことだ。</p>
<p>たとえば、std::distanceという標準ライブラリを実装してみよう。std::distance(first, last)は、イテレーターfirstとlastの距離を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="cf">return</span> last - first ;
}</code></pre></div>
<p>残念ながら、この実装はIteratorがランダムアクセスイテレーターの場合にしか動かない。入力イテレーターに対応させるには、イテレーターを一つづつインクリメントしてlastと等しいかどうか比較する実装が必要になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span> n = <span class="dv">0</span> ;

    <span class="cf">while</span> ( first != last )
    {
        ++n ;
        ++first ;
    }

    <span class="cf">return</span> n ;
}</code></pre></div>
<p>残念ながら、この実装はIteratorにランダムアクセスイテレーターを渡した時に効率が悪い。</p>
<p>ここで必要な実装は、Iteratorがランダムアクセスイテレーターならばlast - firstを使い、そうでなければ地道にインクリメントする遅い実装を使うことだ。Iteratorがランダムアクセスイテレーターかどうかは、以下のコードを使えば、is_random_access_iterator&lt;iterator&gt;で確認できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_random_access_iterator =
    <span class="bu">std::</span>is_same_v&lt;
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;<span class="bu">std::</span>decay_t&lt;Iterator&gt; &gt;::iterator_category,
        <span class="bu">std::</span>random_access_iterator_tag &gt; ;</code></pre></div>
<p>すると、distanceは以下のように書けるのではないか。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ランダムアクセスイテレーターかどうかを判定するコード</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> is_random_access_iterator =
    <span class="bu">std::</span>is_same_v&lt;
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt; <span class="bu">std::</span>decay_t&lt;Iterator&gt; &gt;::iterator_category,
        <span class="bu">std::</span>random_access_iterator_tag &gt; ;

<span class="co">// distance</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="co">// ランダムアクセスイテレーターかどうか確認する</span>
    <span class="cf">if</span> ( is_random_access_iterator&lt;Iterator&gt; )
    {<span class="co">// ランダムアクセスイテレーターなので速い方法を使う</span>
        <span class="cf">return</span> last - first ;
    }
    <span class="cf">else</span>
    { <span class="co">// ランダムアクセスイテレーターではないので遅い方法を使う</span>
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span> n = <span class="dv">0</span> ;

        <span class="cf">while</span> ( first != last )
        {
            ++n ;
            ++first ;
        }

        <span class="cf">return</span> n ;
    }
}</code></pre></div>
<p>残念ながら、このコードは動かない。ランダムアクセスイテレーターではないイテレーターを渡すと、last - firstというコードがコンパイルされるので、コンパイルエラーになる。コンパイラはー、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( is_random_access_iterator&lt;Iterator&gt; )</code></pre></div>
<p>という部分について、is_random_access_iterator&lt;Iterator&gt;の値はコンパイル時に計算できるので、最終的なコード生成の結果としては、if (true)かif (false)なると判断できる。したがってコンパイラーは選択されない分岐のコード生成を行わないことはできる。しかしコンパイルはするので、コンパイルエラーになる。</p>
<p>constexpr ifを使うと、選択されない部分の分岐はコンパイルエラーであってもコンパイルエラーとはならなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// distance</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
<span class="kw">constexpr</span> <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span>
distance( Iterator first, Iterator last )
{
    <span class="co">// ランダムアクセスイテレーターかどうか確認する</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( is_random_access_iterator&lt;Iterator&gt; )
    {<span class="co">// ランダムアクセスイテレーターなので速い方法を使う</span>
        <span class="cf">return</span> last - first ;
    }
    <span class="cf">else</span>
    { <span class="co">// ランダムアクセスイテレーターではないので遅い方法を使う</span>
        <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt;Iterator&gt;::<span class="dt">difference_type</span> n = <span class="dv">0</span> ;

        <span class="cf">while</span> ( first != last )
        {
            ++n ;
            ++first ;
        }

        <span class="cf">return</span> n ;
    }
}</code></pre></div>
<h3 id="超上級者向け解説">超上級者向け解説</h3>
<p>constexpr ifは、実はコンパイル時条件分岐ではない。テンプレートの実体化時に、選択されないブランチのテンプレートの実体化の抑制を行う機能だ。</p>
<p>constexpr ifによって選択されない文はdiscarded statementとなる。discarded statementはテンプレートの実体化の際に実体化されなくなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
   <span class="dt">int</span> get() { <span class="cf">return</span> <span class="dv">0</span> ; } 
} ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">int</span> f(T x)
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same_v&lt;T, <span class="bu">std::</span>decay_t&lt;X&gt; &gt; )
        <span class="cf">return</span> x.get() ;
    <span class="cf">else</span>
        <span class="cf">return</span> x ;

}

<span class="dt">int</span> main()
{
    X x ;
    f( x ) ; <span class="co">// return x.get() </span>
    f( <span class="dv">0</span> ) ; <span class="co">// return x</span>
}</code></pre></div>
<p>f(x)では、return xがdiscarded statementとなるため実体化されない。Xはint型に暗黙に変換できないが問題がなくなる。f(0)ではreturn x.get()がdiscarded statementとなるため実体化されない。int型にはメンバー関数getはないが問題はなくなる。</p>
<p>discarded statementは実体化されないだけで、もちろんテンプレートのエンティティの一部だ。discarded statementがテンプレートのコードとして文法的、意味的に正しくない場合は、もちろんコンパイルエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T x )
{
    <span class="co">// エラー、名前gは宣言されていない</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="kw">false</span> )
        g() ; 

    <span class="co">// エラー、文法違反</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="kw">false</span> )
        !<span class="er">#$</span>%^&amp;*()_+ ;
}</code></pre></div>
<p>何度も説明しているように、constexpr ifはテンプレートの実体化を条件付きで抑制するだけだ。条件付きコンパイルではない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same_v&lt;T, <span class="dt">int</span>&gt; )
    {
        <span class="co">// 常にコンパイルエラー</span>
        <span class="kw">static_assert</span>( <span class="kw">false</span> ) ;
    }
}</code></pre></div>
<p>このコードは常にコンパイルエラーになる。なぜならば、static_assert( false ) はテンプレートに依存しておらず、テンプレートの宣言を解釈するときに、依存名ではないから、そのまま解釈される。</p>
<p>このようなことをしたければ、最初からstatic_assertのオペランドに式を書けばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="kw">static_assert</span>( <span class="bu">std::</span>is_same_v&lt;T, <span class="dt">int</span>&gt; ) ;

    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same_v&lt;T, <span class="dt">int</span>&gt; )
    {
    }
}</code></pre></div>
<p>もし、どうしてもconstexpr文の条件に会うときにだけstatic_assertが使いたい場合もある。これは、constexpr ifをネストしたりしていて、その内容を全部static_assertに書くのが冗長な場合だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( E1 )
        <span class="cf">if</span> <span class="kw">constexpr</span> ( E2 )
            <span class="cf">if</span> <span class="kw">constexpr</span> ( E3 )
            {
                <span class="co">// E1 &amp;&amp; E2 &amp;&amp; E3のときにコンパイルエラーにしたい</span>
                <span class="co">// 実際には常にコンパイルエラー</span>
                <span class="kw">static_assert</span>( <span class="kw">false</span> ) ;
            }
}</code></pre></div>
<p>現実には、E1, E2, E3は複雑な式なので、static_assert( E1 &amp;&amp; E2 &amp;&amp; E3 )と書くのは冗長だ。同じ内容を二度書くのは間違いの元だ。</p>
<p>このような場合、static_assertのオペランドをテンプレート引数に依存するようにすると、constexpr ifの条件に会うときにだけ発動するstatic_assertが書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>  &lt;<span class="kw">typename</span> ... &gt;
<span class="kw">using</span> <span class="dt">false_t</span> = <span class="kw">false</span> ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( E1 )
        <span class="cf">if</span> <span class="kw">constexpr</span> ( E2 )
            <span class="cf">if</span> constepxr ( E3 )
            {
                <span class="kw">static_assert</span>( <span class="dt">false_t</span>&lt;T&gt; ) ;
            }
}</code></pre></div>
<p>このようにfalse_tを使うことで、static_assertをテンプレート引数Tに依存させる。その結果、static_assertの発動をテンプレートの実体化まで遅延させることができる。</p>
<p>constexpr ifは非テンプレートコードでも書くことができるが、その場合は普通のif文と同じだ。</p>
<h3 id="constexpr-ifでは解決できない問題">constexpr ifでは解決できない問題</h3>
<p>constexpr ifは条件付きコンパイルではなく、条件付きテンプレート実体化の抑制なので、最初の問題の解決には使えない。例えば以下のコードはエラーになる</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// do_true_thingの宣言</span>
<span class="dt">void</span> do_true_thing() ;

<span class="co">// do_false_thingの宣言は存在しない</span>

<span class="dt">void</span> f( <span class="dt">bool</span> runtime_value )
{
    <span class="cf">if</span> ( <span class="kw">true</span> )
        do_true_thing() ;
    <span class="cf">else</span>
        do_false_thing() ; <span class="co">// エラー</span>
}</code></pre></div>
<p>理由は、名前do_false_thingは非依存名なのでテンプレートの宣言時に解決されるからだ。</p>
<h3 id="constexpr-ifで解決できる問題">constexpr ifで解決できる問題</h3>
<p>constexpr ifは依存名が関わる場合で、テンプレートの実体化がエラーになる場合に、実体化を抑制させることができる。</p>
<p>例えば、特定の型に対して特別な操作をしたい場合。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    <span class="dt">int</span> get_value() ;
} ;

<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f(T t)
{
    
    <span class="dt">int</span> value{} ;

    <span class="co">// Tの型がXならば特別な処理を行いたい</span>
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same&lt;T, X&gt;{} )
    {
        value = t.get_value() ;
    }
    <span class="cf">else</span>
    {
        value = <span class="kw">static_cast</span>&lt;<span class="dt">int</span>&gt;(t) ;
    }
}</code></pre></div>
<p>もしconstexpr ifがなければ、Tの型がXではないときもt.get_value()という式が実体化され、エラーとなる。</p>
<p>再帰的なテンプレートの特殊化をやめさせたいとき</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// factorial&lt;N&gt;はNの階乗を返す</span>
<span class="kw">template</span> &lt; <span class="bu">std::</span>size_t I  &gt;
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t factorial()
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( I == <span class="dv">1</span> )
    { <span class="cf">return</span> <span class="dv">1</span> ; }
    <span class="cf">else</span>
    { <span class="cf">return</span> I * factorial&lt;I<span class="dv">-1</span>&gt;() ; }
}</code></pre></div>
<p>もしconstexpr ifがなければ、factorial<N-1>が永遠に実体化されコンパイル時ループが停止しない。</p>
<p>機能テストマクロは__cpp_if_constexpr, 値は201606。</p>
<h2 id="初期化文つき条件文">初期化文つき条件文</h2>
<p>C++17では、条件文に初期化文を記述できるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( <span class="dt">int</span> x = <span class="dv">1</span> ; x )
     <span class="co">/*...*/</span> ;

<span class="cf">switch</span>( <span class="dt">int</span> x = <span class="dv">1</span> ; x )
{
    <span class="cf">case</span> <span class="dv">1</span> :
        <span class="co">/*... */</span>;
}</code></pre></div>
<p>これは、以下のコードと同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
    <span class="dt">int</span> x = <span class="dv">1</span> ;
    <span class="cf">if</span> ( x ) ;
}

{
    <span class="dt">int</span> x = <span class="dv">1</span> ;
    <span class="cf">switch</span>( x )
    {
        <span class="cf">case</span> <span class="dv">1</span> : ;
    }
}</code></pre></div>
<p>なぜこのような機能が追加されたかというと、変数を宣言し、if文の条件に変数を使い、if文を実行後は変数を使用しない、というパターンは現実のコードで頻出するからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> * ptr = <span class="bu">std::</span>malloc(<span class="dv">10</span>) ;
<span class="cf">if</span> ( ptr != <span class="kw">nullptr</span> )
{
    <span class="co">// 処理</span>
    <span class="bu">std::</span>free(ptr) ;
}
<span class="co">// これ以降ptrは使わない</span>

FILE * file = <span class="bu">std::</span>fopen(<span class="st">&quot;text.txt&quot;</span>, <span class="st">&quot;r&quot;</span>) ;
<span class="cf">if</span> ( file != <span class="kw">nullptr</span> )
{
    <span class="co">// 処理</span>
    <span class="bu">std::</span>fclose( file ) ;
}
<span class="co">// これ以降fileは使わない</span>

<span class="kw">auto</span> int_ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ;
<span class="cf">if</span> ( ptr )
{
    <span class="co">// 処理</span>
}
<span class="co">// これ以降int_ptrは使わない</span></code></pre></div>
<p>上記のコードには問題がある。これ以降変数は使わないが、変数自体は使えるからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ;
<span class="cf">if</span> ( ptr )
{
    <span class="co">// 処理</span>
}
<span class="co">// これ以降ptrは使わない</span>

<span class="co">// でも使える</span>
<span class="dt">int</span> value = *ptr ;</code></pre></div>
<p>変数を使えないようにするには、ブロックスコープで囲むことで、変数をスコープから外してやればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">{
    <span class="kw">auto</span> int_ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ;
    <span class="cf">if</span> ( ptr )
    {
        <span class="co">// 処理</span>
    }
    <span class="co">// ptrは破棄される</span>
}
<span class="co">// これ以降ptrは使わないし使えない</span></code></pre></div>
<p>このようなパターンは頻出するので、初期化文つきの条件文が追加された。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="cf">if</span> ( <span class="kw">auto</span> ptr = <span class="bu">std::</span>make_unique&lt;<span class="dt">int</span>&gt;(<span class="dv">42</span>) ; ptr )
{
    <span class="co">// 処理</span>
}</code></pre></div>
<h2 id="クラステンプレートのコンストラクターからの実引数推定">クラステンプレートのコンストラクターからの実引数推定</h2>
<p>C++17ではクラステンプレートのコンストラクターの実引数からテンプレート実引数の推定が行えるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="kw">struct</span> X
{
    X( T t ) { }
} ;

<span class="dt">int</span> main()
{
    X x1(<span class="dv">0</span>) ; <span class="co">// X&lt;int&gt;</span>
    X x2(<span class="fl">0.0</span>) ; <span class="co">// X&lt;double&gt;</span>
    X x3(<span class="st">&quot;hello&quot;</span>) ; <span class="co">// X&lt;char const *&gt;</span>
}</code></pre></div>
<p>これは関数テンプレートが実引数からテンプレート実引数の推定が行えるのと同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T t ) { }

<span class="dt">int</span> main()
{
    f( <span class="dv">0</span> ) ; <span class="co">// f&lt;int&gt;</span>
    f( <span class="fl">0.0</span> ) ; <span class="co">// f&lt;double&gt;</span>
    f( <span class="st">&quot;hello&quot;</span> ) ; <span class="co">// f&lt;char const *&gt;</span>
}</code></pre></div>
<h3 id="実引数ガイド">実引数ガイド</h3>
<p>クラステンプレートのコンストラクターからの実引数は便利だが、クラスのコンストラクターはクラステンプレートのテンプレートパラメーターに一致しない場合もある。そのような場合はそのままでは実引数推定ができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// コンテナー風のクラス</span>
<span class="kw">template</span> &lt;<span class="kw">typename</span> T &gt;
<span class="kw">class</span> Container
{
    <span class="bu">std::</span>vector&lt;T&gt; c ;
<span class="kw">public</span> :
    <span class="co">// 初期化にイテレーターのペアを取る。</span>
    <span class="co">// IteratorはTではない。</span>
    <span class="co">// Tは推定できない</span>
    <span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
    Container( Iterator first, Iterator last )
        : c( first, last )
    { }
} ;


<span class="dt">int</span> main()
{
    <span class="dt">int</span> a[] = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="co">// エラー</span>
    <span class="co">// Tを推定できない</span>
    Container c( <span class="bu">std::</span>begin(a), <span class="bu">std::</span>end(a) ) ;
}</code></pre></div>
<p>このため、C++17には推定ガイドという機能が提供されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">テンプレート名( 引数リスト ) -&gt; テンプレートid ;</code></pre></div>
<p>これを使うと、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Iterator &gt;
Container( Iterator, Iterator )
-&gt; Container&lt; <span class="kw">typename</span> <span class="bu">std::</span>iterator_traits&lt; Iterator &gt;::<span class="dt">value_type</span> &gt; ;</code></pre></div>
<p>C++コンパイラーはこの推定ガイドを使って、Container&lt;T&gt;::Container(Iterator, Iterator)からは、Tをstd::iterator_traits&lt; Iterator&gt;::value_typeとして推定すればいいのだと判断できる。</p>
<p>例えば、初期化リストに対応するには以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="kw">template</span> &lt;<span class="kw">typename</span> T &gt;
<span class="kw">class</span> Container
{
    <span class="bu">std::</span>vector&lt;T&gt; c ;
<span class="kw">public</span> :

    Container( <span class="bu">std::</span>initializer_list&lt;T&gt; init )
        : c( init )
    { }
} ;


<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
Container( <span class="bu">std::</span>initializer_list&lt;T&gt; ) -&gt; Container&lt;T&gt; ;


<span class="dt">int</span> main()
{
    Container c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;
}</code></pre></div>
<p>C++コンパイラーはこの推定ガイドから、Container&lt;T&gt;::Container( std::initializer_list&lt;T&gt; )の場合はTをTとして推定すればよいことがわかる。</p>
<p>機能テストマクロは__cpp_deduction_guides, 値は201606。</p>
<h2 id="autoによる非型テンプレートパラメーターの宣言">autoによる非型テンプレートパラメーターの宣言</h2>
<p>C++17では非型テンプレートパラメーターの宣言にautoを使うことができるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">auto</span> x &gt;
<span class="kw">struct</span> X { } ;

<span class="dt">void</span> f() { }

<span class="dt">int</span> main()
{
    X&lt;<span class="dv">0</span>&gt; x1 ;
    X&lt;<span class="dv">0l</span>&gt; x2 ;
    X&lt;&amp;f&gt; x3 ;
}</code></pre></div>
<p>これはC++14までであれば、以下のように書かなければならなかった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T, T x &gt;
<span class="kw">struct</span> X { } ;

<span class="dt">void</span> f() { }

<span class="dt">int</span> main()
{
    X&lt;<span class="dt">int</span>, <span class="dv">0</span>&gt; x1 ;
    X&lt;<span class="dt">long</span>, <span class="dv">0l</span>&gt; x2 ;
    X&lt;<span class="dt">void</span>(*), &amp;f&gt; x3 ;
}</code></pre></div>
<p>機能テストマクロは__cpp_template_auto, 値は201606</p>
<h2 id="using属性名前空間">using属性名前空間</h2>
<p>C++17では、属性名前空間にusingディレクティブのような記述ができるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// [[extention::foo, extention::bar]]と同じ</span>
[ <span class="kw">using</span> extention : foo, bar ]] <span class="dt">int</span> x ;</code></pre></div>
<p>属性トークンには、属性名前空間をつけることができる。これにより、独自拡張の属性トークンの名前の衝突を避けることができる。</p>
<p>例えば、あるC++コンパイラーには独自拡張としてfoo, barという属性トークンがあり、別のC++コンパイラーも同じく独自拡張としてfoo, barという属性トークンを持っているが、それぞれ意味が違っている場合、コードの意味も違ってしまう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[ <span class="at">foo</span>, <span class="at">bar</span> ]] <span class="dt">int</span> x ;</code></pre></div>
<p>このため、C++には属性名前空間という文法が用意されている。注意深いC++コンパイラーは独自拡張の属性トークンには属性名前空間を設定していることだろう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">[[ <span class="at">extention::foo</span>, <span class="at">extention::bar</span> ]] <span class="dt">int</span> x ;</code></pre></div>
<p>問題は、これをいちいち記述するのは面倒だということだ。</p>
<p>C++17では、using属性名前空間という機能により、usingディレクティブのような名前空間の省略が可能になった。</p>
<h2 id="非標準属性の無視">非標準属性の無視</h2>
<p>C++17では、非標準の属性トークンは無視される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK、無視される</span>
[[ <span class="at">wefapiaofeaofjaopfij</span> ]] <span class="dt">int</span> x ;</code></pre></div>
<p>属性はC++コンパイラーによる独自拡張をC++の規格に準拠する形で穏便に追加するための機能だ。その属性のためにコンパイルエラーになった場合、結局Cプリプロセッサーを使うか、煩わしさから独自の文法が使われてしまう。そのためこの機能は必須だ。</p>
<h2 id="構造化束縛">構造化束縛</h2>
<p>C++17で追加された構造化束縛は多値を分解して受け取るための変数宣言の文法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a[] = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
    <span class="kw">auto</span> [a,b,c] = a ;

    <span class="co">// a == 1</span>
    <span class="co">// b == 2</span>
    <span class="co">// c == 3</span>
}</code></pre></div>
<p>C++では、様々な方法で多値を扱うことができる。例えば配列、クラス、tuple, pairだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> a[] = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span> } ;
<span class="kw">struct</span> B
{
    <span class="dt">int</span> a ;
    <span class="dt">double</span> b ;
    <span class="bu">std::</span>string c ;
} ;

B b{ <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span>} ;

<span class="bu">std::</span>tuple&lt;<span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string&gt; c { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;

<span class="bu">std::</span>pair&lt; <span class="dt">int</span>, <span class="dt">int</span>&gt; d{ <span class="dv">1</span>, <span class="dv">2</span> } ;</code></pre></div>
<p>C++の関数は配列以外の多値を返すことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}</code></pre></div>
<p>多値を受け取るには、これまでは多値を塊として受け取るか、ライブラリで分解して受け取るしかなかった。</p>
<p>多値を塊で受け取るには以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> result = f() ;
    
    <span class="bu">std::</span>cout &lt;&lt; <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(result) &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> 
        &lt;&lt; <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(result) &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>
        &lt;&lt; <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(result) &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>多値をライブラリで受け取るには以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a ;
    <span class="dt">double</span> b ;
    <span class="bu">std::</span>string c ;

    <span class="bu">std::</span>tie(a, b, c ) = f() ;
    
    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> 
        &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>
        &lt;&lt; c &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>構造化束縛を使うと、以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; f()
{
    <span class="cf">return</span> { <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span> } ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> [a, b, c] = f() ;
    
    <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> 
        &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>
        &lt;&lt; c &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>変数の型はそれぞれ対応する多値の型になる。この場合、a, b, cはそれぞれint, double, std::string型になる。</p>
<p>tupleだけではなく、pairも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; p( <span class="dv">1</span>, <span class="dv">2</span> ) ;

    <span class="kw">auto</span> [a,b] = p ;

    <span class="co">// aはint型、値は1</span>
    <span class="co">// bはint型、値は2</span>
}</code></pre></div>
<p>構造化束縛はif文とswitch文、for文でも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="cf">if</span> ( <span class="kw">auto</span>[a,b,c] = expr ; a )
    { }
    <span class="cf">switch</span>( <span class="kw">auto</span>[a,b,c] = expr ; a )
    { }
    <span class="cf">for</span> ( <span class="kw">auto</span>[a,b,c] = expr ; <span class="kw">false</span> ; ) 
    { }
}</code></pre></div>
<p>構造化束縛はrange-based for文にも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>map&lt; <span class="bu">std::</span>string, <span class="bu">std::</span>string &gt; translation_table
    {
        {<span class="st">&quot;dog&quot;</span>, <span class="st">&quot;犬&quot;</span>},
        {<span class="st">&quot;cat&quot;</span>, <span class="st">&quot;猫&quot;</span>},
        {<span class="st">&quot;answer&quot;</span>, <span class="st">&quot;42&quot;</span>} 
    } ;
    
    <span class="cf">for</span> ( <span class="kw">auto</span> [key, value] : translation_table )
    {
        <span class="bu">std::</span>cout&lt;&lt;
            <span class="st">&quot;key=&quot;</span>&lt;&lt; key &lt;&lt;
            <span class="st">&quot;, value=&quot;</span> &lt;&lt; value &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<p>これは、mapの要素型std::pair&lt;const std::string, std::string&gt;を構造化束縛[key, value]で受けている。</p>
<p>構造化束縛は配列にも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> values[] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> [a,b,c] = values ;
}</code></pre></div>
<p>構造化束縛はクラスにも使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> Values
{
    <span class="dt">int</span> a ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string c ;
} ;

<span class="dt">int</span> main()
{
    Values values{ <span class="dv">1</span>, <span class="fl">2.0</span>, <span class="st">&quot;hello&quot;</span>} ;

    <span class="kw">auto</span> [a,b,c] = values ;
}</code></pre></div>
<p>構造化束縛でクラスを使う場合は、非staticデータメンバーはすべてひとつのクラスのpublicなメンバーでなければならない。</p>
<p>構造化束縛はconstexprにはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[] = { <span class="dv">1</span>,<span class="dv">2</span> } ;

    <span class="co">// エラー</span>
    <span class="kw">constexpr</span> <span class="kw">auto</span> [a,b] = expr ;
}</code></pre></div>
<h3 id="超上級者向け解説-1">超上級者向け解説</h3>
<p>構造化束縛は、変数の宣言のうち、<strong>構造化束縛宣言(structured binding declaration)</strong>に分類される文法で記述する。構造化束縛宣言となる宣言は、単純宣言(simple-declaration)とfor-range宣言(for-range-declaration)のうち、[識別子リスト]があるものだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">単純宣言:
    属性 <span class="kw">auto</span> CV修飾子(省略可) リファレンス修飾子(省略可) [ 識別子リスト ] 初期化子 ;

<span class="cf">for</span>-range宣言:
    属性 <span class="kw">auto</span> CV修飾子(省略可) リファレンス修飾子(省略可) [ 識別子リスト ] ;

識別子リスト:
    コンマで区切られた識別子

初期化子:
    = 式
    { 式 }
    ( 式 )</code></pre></div>
<p>以下は単純宣言のコード例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> e1[] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">struct</span> { <span class="dt">int</span> a,b,c ; } e2{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> e3 = <span class="bu">std::</span>make_tuple(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>) ;
    
    <span class="co">// &quot;= 式&quot;の例</span>
    <span class="kw">auto</span> [a,b,c] = e1 ;
    <span class="kw">auto</span> [d,e,f] = e2 ;
    <span class="kw">auto</span> [g,h,i] = e3 ;
    
    <span class="co">// &quot;{式}&quot;, &quot;(式)&quot;の例</span>
    <span class="kw">auto</span> [j,k,l]{e1} ;
    <span class="kw">auto</span> [m,n,o](e1) ;

    <span class="co">// CV修飾子とリファレンス修飾子を使う例</span>
    <span class="kw">auto</span> <span class="at">const</span> &amp; [p,q,r] = e1 ;
}</code></pre></div>
<p>以下はfor-range宣言の例だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pair&lt;<span class="dt">int</span>, <span class="dt">int</span>&gt; pairs[] = { {<span class="dv">1</span>,<span class="dv">2</span>}, {<span class="dv">3</span>,<span class="dv">4</span>}, {<span class="dv">5</span>,<span class="dv">6</span>}} ;
    
    <span class="cf">for</span> ( <span class="kw">auto</span> [a, b] : pairs )
    {
        <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; <span class="st">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;
    }
}</code></pre></div>
<h3 id="構造化束縛宣言の仕様">構造化束縛宣言の仕様</h3>
<p>構造化束縛の構造化束縛宣言は以下のように解釈される。</p>
<p>構造化束縛宣言によって宣言される変数の数は、初期化子の多値の数と一致していなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 2個の値を持つ</span>
    <span class="dt">int</span> expr[] = {<span class="dv">1</span>,<span class="dv">2</span>} ;

    <span class="co">// エラー、変数が少なすぎる</span>
    <span class="kw">auto</span>[a] = expr ; 
    <span class="co">// エラー、変数が多すぎる</span>
    <span class="kw">auto</span>[b,c,d] = expr ;
}</code></pre></div>
<p>構造化束縛宣言で宣言されるそれぞれの変数名について、記述された通りの属性、CV修飾子、リファレンス修飾子の変数が宣言される。</p>
<h3 id="初期化子の型が配列の場合">初期化子の型が配列の場合</h3>
<p>初期化子が配列の場合、それぞれの変数はそれぞれの配列の要素で初期化される。</p>
<p>リファレンス修飾子がない場合、それぞれの変数はコピー初期化される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> [a,b,c] = expr ;
}</code></pre></div>
<p>これは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{

    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="dt">int</span> a = expr[<span class="dv">0</span>] ;
    <span class="dt">int</span> b = expr[<span class="dv">1</span>] ;
    <span class="dt">int</span> c = expr[<span class="dv">2</span>] ;
}</code></pre></div>
<p>リファレンス修飾子がある場合、変数はリファレンスとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;
    <span class="kw">auto</span> &amp; [a,b,c] = expr ;
    <span class="kw">auto</span> &amp;&amp; [d,e,f] = expr ;
}</code></pre></div>
<p>これは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[<span class="dv">3</span>] = {<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="dt">int</span> &amp; a = expr[<span class="dv">0</span>] ;
    <span class="dt">int</span> &amp; b = expr[<span class="dv">1</span>] ;
    <span class="dt">int</span> &amp; c = expr[<span class="dv">2</span>] ;

    <span class="dt">int</span> &amp;&amp; d = expr[<span class="dv">0</span>] ;
    <span class="dt">int</span> &amp;&amp; e = expr[<span class="dv">1</span>] ;
    <span class="dt">int</span> &amp;&amp; f = expr[<span class="dv">2</span>] ;
}</code></pre></div>
<p>もし、変数の型が配列の場合、配列の要素はそれぞれ対応する配列の要素で初期化される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[][<span class="dv">2</span>] = {{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">1</span>,<span class="dv">2</span>}} ;
    <span class="kw">auto</span> [a,b] = expr ;
}</code></pre></div>
<p>これは、以下と同じ意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> expr[][<span class="dv">2</span>] = {{<span class="dv">1</span>,<span class="dv">2</span>},{<span class="dv">1</span>,<span class="dv">2</span>}} ;

    <span class="dt">int</span> a[<span class="dv">2</span>] = { expr[<span class="dv">0</span>][<span class="dv">0</span>], expr[<span class="dv">0</span>][<span class="dv">1</span>] } ;
    <span class="dt">int</span> b[<span class="dv">2</span>] = { expr[<span class="dv">1</span>][<span class="dv">0</span>], expr[<span class="dv">1</span>][<span class="dv">1</span>] } ;    
}</code></pre></div>
<h3 id="初期化子の型が配列ではなくstdtuple_sizeeが完全形の名前である場合">初期化子の型が配列ではなく、std::tuple_size&lt;E&gt;が完全形の名前である場合</h3>
<p>構造化束縛宣言の初期化子の型Eが配列ではない場合で、std::tuple_size&lt;E&gt;が完全形の名前である場合、</p>
<p>構造化束縛宣言の初期化子の型をE、その値をeとする。構造化束縛宣言で宣言されるひとつ目の変数を0, ふたつ目の変数を1...とインクリメントされていくインデックスをiとする。</p>
<p>std::tuple_size&lt;E&gt;::valueは整数のコンパイル時定数式で、その値は初期化子の値の数でなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// std::tuple&lt; int, int, int &gt;</span>
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="kw">auto</span> [a,b,c] = e ;

    <span class="co">// std::tuple_size&lt;decltype(e)&gt;::sizeは3</span>
}</code></pre></div>
<p>それぞれの値を取得するために、非修飾名getが型Eのクラススコープから探される。getが見つかった場合、それぞれの変数の初期化子はe.get&lt;i&gt;()となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> [a,b,c] = e ;</code></pre></div>
<p>という構造化束縛宣言は、以下の意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">type a = e.get&lt;<span class="dv">0</span>&gt;() ;
type b = e.get&lt;<span class="dv">1</span>&gt;() ;
type c = e.get&lt;<span class="dv">2</span>&gt;() ;</code></pre></div>
<p>そのようなgetの宣言が見つからない場合、初期化子はget&lt;i&gt;(e)となる。この場合、getは連想名前空間から探される。通常の非修飾名前検索は行われない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// ただし通常の非修飾名前検索は行われない。</span>
type a = get&lt;<span class="dv">0</span>&gt;(e) ;
type b = get&lt;<span class="dv">1</span>&gt;(e) ;
type c = get&lt;<span class="dv">2</span>&gt;(e) ;</code></pre></div>
<p>構造化束縛宣言で宣言される変数の型は以下のように決定される。</p>
<p>変数の型typeは&quot;std::tuple_element&lt;i, E&gt;::type&quot;となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>tuple_element&lt;<span class="dv">0</span>, E&gt;::type a = get&lt;<span class="dv">0</span>&gt;(e) ;
<span class="bu">std::</span>tuple_element&lt;<span class="dv">1</span>, E&gt;::type b = get&lt;<span class="dv">1</span>&gt;(e) ;
<span class="bu">std::</span>tuple_element&lt;<span class="dv">2</span>, E&gt;::type c = get&lt;<span class="dv">2</span>&gt;(e) ;</code></pre></div>
<p>以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="kw">auto</span> [a,b,c] = e ;
}</code></pre></div>
<p>以下とほぼ同等の意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    
    <span class="kw">using</span> E = <span class="kw">decltype</span>(e) ;

    <span class="bu">std::</span>tuple_element&lt;<span class="dv">0</span>, E &gt;::type &amp; a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(e) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">1</span>, E &gt;::type &amp; b = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(e) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">2</span>, E &gt;::type &amp; c = <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(e) ;
}</code></pre></div>
<p>以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="kw">auto</span> &amp;&amp; [a,b,c] = <span class="bu">std::</span>move(e) ;
}</code></pre></div>
<p>以下のような意味になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> e = <span class="bu">std::</span>make_tuple( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    
    <span class="kw">using</span> E = <span class="kw">decltype</span>(e) ;

    <span class="bu">std::</span>tuple_element&lt;<span class="dv">0</span>, E &gt;::type &amp;&amp; a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(<span class="bu">std::</span>move(e)) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">1</span>, E &gt;::type &amp;&amp; b = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(<span class="bu">std::</span>move(e)) ;
    <span class="bu">std::</span>tuple_element&lt;<span class="dv">2</span>, E &gt;::type &amp;&amp; c = <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(<span class="bu">std::</span>move(e)) ;
}</code></pre></div>
<h3 id="上記以外の場合">上記以外の場合</h3>
<p>上記以外の場合、構造化束縛宣言の初期化子の型Eはクラス型で、すべての非staticデータメンバーはpublicの直接のメンバーであるか、あるいは単一の曖昧ではないpublic基本クラスのメンバーである必要がある。Eに匿名unionメンバーがあってはならない。</p>
<p>以下は型Eとして適切なクラスの例である</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> A
{
    <span class="dt">int</span> a, b, c ;
} ;

<span class="kw">struct</span> B : A { } ;</code></pre></div>
<p>以下は型Eとして不適切なクラスの例である。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// public以外の非staticデータメンバーがある</span>
<span class="kw">struct</span> A
{
<span class="kw">public</span> :
    <span class="dt">int</span> a ;
<span class="kw">private</span> :
    <span class="dt">int</span> b ;
} ;



<span class="kw">struct</span> B
{
    <span class="dt">int</span> a ;
} ;
<span class="co">// クラスにも基本クラスにも非staticデータメンバーがある。</span>
<span class="kw">struct</span> C : B
{
    <span class="dt">int</span> b ;
} ;

<span class="co">// 匿名unionメンバーがある</span>
<span class="kw">struct</span> D
{
    <span class="kw">union</span>
    {
        <span class="dt">int</span> i ;
        <span class="dt">double</span> d ;
    }
} ;</code></pre></div>
<p>型Eの非staticデータメンバーは宣言された順番で多値として認識される。</p>
<p>以下のコードは、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">struct</span> { <span class="dt">int</span> x, y, z ; } e{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="kw">auto</span> [a,b,c] = e ;
}</code></pre></div>
<p>以下のコードと意味的に等しい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">struct</span> { <span class="dt">int</span> x, y, z ; } e{<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>} ;

    <span class="dt">int</span> a = e.x ;
    <span class="dt">int</span> b = e.y ;
    <span class="dt">int</span> c = e.z ;
}</code></pre></div>
<p>構造化束縛はビットフィールドに対応している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> S
{
    <span class="dt">int</span> x : <span class="dv">2</span> ;
    <span class="dt">int</span> y : <span class="dv">4</span> ;
} ;

<span class="dt">int</span> main()
{
    S e{<span class="dv">1</span>,<span class="dv">3</span>} ; ;
    <span class="kw">auto</span> [a,b] = e ;
}</code></pre></div>
<p>機能テストマクロは__cpp_structured_bindings, 値は201606。</p>
<h2 id="inline変数">inline変数</h2>
<p>C++17では変数にinlineキーワードを指定できるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">int</span> variable ;</code></pre></div>
<p>このような変数をinline変数と呼ぶ。その意味はinline関数と同じだ。</p>
<h3 id="inlineの歴史的な意味">inlineの歴史的な意味</h3>
<p>今は昔、本書執筆から30年以上は昔に、inlineキーワードがC++に追加された。</p>
<p>inlineの現在の意味は誤解されている。</p>
<p>inline関数の意味は、「関数を強制的にインライン展開させるための機能」<strong>ではない</strong>。</p>
<p>大事なことなのでもう一度書くが、inline関数の意味は、「関数を強制的にインライン展開させるための機能」<strong>ではない</strong>。</p>
<p>確かに、かつてinline関数の意味は、関数を強制的にインライン展開させるための機能だった。</p>
<p>関数のインライン展開とは、例えば以下のようなコードがあったとき、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> min( <span class="dt">int</span> a, <span class="dt">int</span> b )
{ <span class="cf">return</span> a &lt; b ? a : b ; }

<span class="dt">int</span> main()
{
    <span class="dt">int</span> a, b ;
    <span class="bu">std::</span>cin &gt;&gt; a &gt;&gt; b ;

    <span class="co">// aとbのうち小さい方を選ぶ</span>
    <span class="dt">int</span> value = min( a, b ) ;
}</code></pre></div>
<p>この関数minは十分に小さく、関数呼び出しのコストは無視できないオーバーヘッドになるため、以下のような最適化が考えられる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> a, b ;
    <span class="bu">std::</span>cin &gt;&gt; a &gt;&gt; b ;

    <span class="dt">int</span> value = a &lt; b ? a : b ;
}</code></pre></div>
<p>このように関数の中身を展開することを、関数のインライン展開という。</p>
<p>人間が関数のインライン展開を手で行うのは面倒だ。それにコードが読みにくい。&quot;min(a,b)&quot;と&quot;a&lt;b?a:b&quot;のどちらが読みやすいだろうか。</p>
<p>幸い、C++コンパイラーはインライン展開を自動的に行えるので人間が苦労する必要はない。</p>
<p>インライン展開は万能の最適化ではない。インライン展開をすると逆に遅くなる場合もある。</p>
<p>例えば、ある関数をコンパイルした結果のコードサイズが1KBあったとして、その関数を呼んでいる箇所がプログラム中に1000件ある場合、プログラム全体のサイズは1MB増える。コードサイズが増えるということは、CPUのキャッシュを圧迫する。</p>
<p>例えば、ある関数の実行時間が関数呼び出しの実行時間に比べて桁違いに長い時、関数呼び出しのコストを削減するのは意味がない。</p>
<p>したがって関数のインライン展開という最適化を適用すべきかどうかを決定するには、関数のコードサイズが十分に小さい時、関数の実行時間が十分に短い時、タイトなループの中など、様々な条件を考慮しなければならない。</p>
<p>昔のコンパイラー技術が未熟だった時代のC++コンパイラーは関数をインライン展開するべきかどうかの判断ができなかった。そのためinlineキーワードが追加された。インライン展開してほしい関数をinline関数にすることで、コンパイラーはその関数がインライン展開するべき関数だと認識する。</p>
<h3 id="現代のinlineの意味">現代のinlineの意味</h3>
<p>現代では、コンパイラー技術の発展によりC++コンパイラーは十分に賢くなったので、関数をインライン展開させる目的でinlineキーワードを使う必要はない。実際、現代のC++コンパイラーはinlineキーワードを無視する。関数をインライン展開すべきかどうかはコンパイラーが判断できる。</p>
<p>inlineキーワードにはインライン展開以外に、もうひとつの意味がある。ODR(One Definition Rule、定義はひとつの原則)の回避だ。</p>
<p>C++では、定義はプログラム中にひとつしか書くことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f() ; <span class="co">// OK、宣言</span>
<span class="dt">void</span> f() ; <span class="co">// OK、再宣言</span>

<span class="dt">void</span> f() { } <span class="co">// OK、定義</span>

<span class="dt">void</span> f() { } <span class="co">// エラー、再定義</span></code></pre></div>
<p>通常は、関数を使う場合には宣言だけを書いて使う。定義はどこかひとつの翻訳単位に書いておけばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// f.h</span>

<span class="dt">void</span> f() ;

<span class="co">// f.cpp</span>

<span class="dt">void</span> f() { }

<span class="co">// main.cpp</span>

<span class="pp">#include </span><span class="im">&quot;f.h&quot;</span>

<span class="dt">int</span> main()
{
    f() ;
}</code></pre></div>
<p>しかし、関数のインライン展開をするには、コンパイラーの実装上の都合で、関数の定義が同じ翻訳単位になければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">inline</span> <span class="dt">void</span> f() ;

<span class="dt">int</span> main()
{
    <span class="co">// エラー、定義がない</span>
    f() ; 
}</code></pre></div>
<p>しかし、翻訳単位ごとに定義すると、定義が重複してODRに違反する。</p>
<p>C++ではこの問題を解決するために、inline関数は定義が同一であれば、複数の翻訳単位で定義されてもよいことにしている。つまりODRに違反しない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// a.cpp</span>

<span class="kw">inline</span> <span class="dt">void</span> f() { }

<span class="dt">void</span> a()
{
    f() ;
}

<span class="co">// b.cpp</span>

<span class="co">// OK、inline関数</span>
<span class="kw">inline</span> <span class="dt">void</span> f() { }

<span class="dt">void</span> b()
{
    f() ;
}</code></pre></div>
<p>これは例のために同一のinline関数を直接記述しているが、inline関数は定義を同一性を保証させるため、通常はヘッダーファイルに書いて#includeして使う。</p>
<h3 id="inline変数の意味">inline変数の意味</h3>
<p>inline変数は、ODRに違反せず変数の定義の重複を認める。同じ名前のinline変数は同じ変数を指す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// a.cpp</span>

<span class="kw">inline</span> <span class="dt">int</span> data ;

<span class="dt">void</span> a() { ++data ; }

<span class="co">// b.cpp</span>

<span class="kw">inline</span> <span class="dt">int</span> data ;

<span class="dt">void</span> b() { ++data ; }

<span class="co">// main.cpp</span>

<span class="kw">inline</span> <span class="dt">int</span> data ;

<span class="dt">int</span> main()
{
    a() ;
    b() ;

    data ; <span class="co">// 2</span>
}</code></pre></div>
<p>この例で関数a, bの中の変数dataは同じ変数を指している。変数dataはstaticストレージ上に構築された変数なのでプログラムの開始時にゼロで初期化される。2回インクリメントされるので値は2となる。</p>
<p>これにより、クラスの非staticデータメンバーの定義を書かなくてすむようになる。</p>
<p>C++17以前のC++では、以下のように書かなければならなかったが、</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// S.h</span>

<span class="kw">struct</span> S
{
    <span class="at">static</span> <span class="dt">int</span> data ;
} ;

<span class="co">// S.cpp</span>

<span class="dt">int</span> S::data ;</code></pre></div>
<p>C++17では、以下のように書けばよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// S.h</span>

<span class="kw">struct</span> S
{
    <span class="kw">inline</span> <span class="at">static</span> <span class="dt">int</span> data ;
} ;</code></pre></div>
<p>S.cppに変数S::dataの定義を書く必要はない。</p>
<p>機能テストマクロは__cpp_inline_variables, 値は201606。</p>
<h2 id="可変長using宣言">可変長using宣言</h2>
<p>この機能は超上級者向けだ。</p>
<p>C++17ではusing宣言をカンマで区切ることができるようになった。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> x, y ;

<span class="dt">int</span> main()
{
    <span class="kw">using</span> ::x, ::y ;
}</code></pre></div>
<p>これは、C++14で</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> ::x ;
<span class="kw">using</span> ::y ;</code></pre></div>
<p>と書くのと等しい。</p>
<p>C++17では、using宣言でパック展開ができるようになった。この機能に正式な名前はついていないが、可変長using宣言(Variadic using declaration)と呼ぶのがわかりやすい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types &gt;
<span class="kw">struct</span> S : Types ...
{
    <span class="kw">using</span> Types::<span class="kw">operator</span>() ... ;
    <span class="dt">void</span> <span class="kw">operator</span> ()( <span class="dt">long</span> ) { }
} ;


<span class="kw">struct</span> A
{
    <span class="dt">void</span> <span class="kw">operator</span> () ( <span class="dt">int</span> ) { }
} ;

<span class="kw">struct</span> B
{
    <span class="dt">void</span> <span class="kw">operator</span> () ( <span class="dt">double</span> ) { }
} ;

<span class="dt">int</span> main()
{
    S&lt;A, B&gt; s ;
    s(<span class="dv">0</span>) ; <span class="co">// A::operator()</span>
    s(<span class="dv">0L</span>) ; <span class="co">// S::operator()</span>
    s(<span class="fl">0.0</span>) ; <span class="co">// B::operator()</span>
}</code></pre></div>
<p>機能テストマクロは__cpp_variadic_using, 値は201611。</p>
<h2 id="stdbyte-バイトを表現する型">std::byte バイトを表現する型</h2>
<p>C++17では、バイトを表現する型が入った。std::byteは&lt;cstddef&gt;で定義されている。ライブラリでもあるのだがコア言語で特別な型として扱われている。</p>
<p>バイトとはC++のメモリモデルにおけるストレージの単位で、C++においてユニークなアドレスが付与される最小単位だ。C++の規格は未だに1バイトが具体的に何ビットであるのかを規定していない。これは過去にバイトのサイズが8ビットではないアーキテクチャが存在したためだ。</p>
<p>バイトのビット数は&lt;climits&gt;で定義されているプリプロセッサーマクロ、CHAR_BITで知ることができる。</p>
<p>C++17では、1バイトはUTF-8の8ビットの1コード単位をすべて表現できると規定している。</p>
<p>C++では、1バイトのストレージはunsigned char型かstd::byte型で表現できる。複数バイトが連続するストレージは、unsigned charの配列型、もしくはstd::byteの配列型として表現できる。</p>
<p>std::byte型は、&lt;cstddef&gt;で以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std
{
    <span class="kw">enum</span> <span class="kw">class</span> byte : <span class="dt">unsigned</span> <span class="dt">char</span> { } ;
}</code></pre></div>
<p>std::byteはライブラリとしてscoped enum型で定義されている。これにより、他の整数型からの暗黙の型変換が行えない。</p>
<p>値0x12のstd::byte型の変数は以下のように定義できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte b{<span class="bn">0x12</span>} ;
}</code></pre></div>
<p>std::byte型の値が欲しい場合は、以下のように書くことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte b{} ;

    b = <span class="bu">std::</span>byte( <span class="dv">1</span> ) ;
    b = <span class="bu">std::</span>byte{ <span class="dv">1</span> } ;
    b = <span class="kw">static_cast</span>&lt; <span class="bu">std::</span>byte &gt;( <span class="dv">1</span> )
}</code></pre></div>
<p>std::byte型は他の数値型からは暗黙に型変換できない。これによりうっかりと型を取り違えてバイト型と他の型を演算してしまうことを防ぐことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、()による初期化はint型からの暗黙の変換が入る</span>
    <span class="bu">std::</span>byte b1(<span class="dv">1</span>) ;

    <span class="co">// エラー、=による初期化はint型からの暗黙の変換が入る</span>
    <span class="bu">std::</span>byte b2 = <span class="dv">1</span> ;

    <span class="bu">std::</span>byte b{} ;

    <span class="co">// エラー、operator =によるint型の代入は暗黙の変換が入る</span>
    b = <span class="dv">1</span> ;
    <span class="co">// エラー、operator =によるdouble型の代入は暗黙の変換が入る</span>
    b = <span class="fl">1.0</span> ;
}</code></pre></div>
<p>std::byte型は{}によって初期化するが、縮小変換を禁止するルールにより、std::byte型が表現できる値の範囲でなければエラーとなる。</p>
<p>例えば、今std::byteが8ビットで、最小値が0、最大値が255の環境だとする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// エラー、表現できる値の範囲ではない</span>
    <span class="bu">std::</span>byte b1{<span class="dv">-1</span>} ;
    <span class="co">// エラー、表現できる値の範囲ではない</span>
    <span class="bu">std::</span>byte b2{<span class="dv">256</span>} ;
}</code></pre></div>
<p>std::byteは一部の演算子がオーバーロードされているので、通常の整数型のように使うことができる。ただし、バイトをビット列演算するのに使う一部の演算子だけだ。</p>
<p>具体的には、以下に示すシフト、ビットOR、ビット列AND、ビット列XOR、ビット列NOTだ。</p>
<pre><code>&lt;&lt;= &lt;&lt; 
&gt;&gt;= &gt;&gt;
|=  |
&amp;=  &amp;
^=  ^
~</code></pre>
<p>四則演算などの演算子はサポートしていない。</p>
<p>std::byteはstd::to_intenger&lt;IntType&gt;(std::byte)により、IntType型の整数型に変換できる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte b{<span class="dv">42</span>} ;

    <span class="co">// int型の値は42</span>
    <span class="kw">auto</span> i = <span class="bu">std::</span>to_integer&lt;<span class="dt">int</span>&gt;(b) ;
}</code></pre></div>
<h1 id="c17の型安全な値を格納するライブラリ">C++17の型安全な値を格納するライブラリ</h1>
<p>C++17では型安全に値を格納するライブラリとして、variant, any, optionalが追加された。</p>
<h2 id="variant-型安全なunion">variant : 型安全なunion</h2>
<h3 id="使い方">使い方</h3>
<p>ヘッダーファイル&lt;variant&gt;で定義されているvariantは、型安全なunionとして使うことができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;variant&gt;</span>

<span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;

    <span class="co">// int, double, std::stringのいずれかを格納するvariant</span>
    <span class="co">// コンストラクターは最初の型をデフォルト構築</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; x ;

    x = <span class="dv">0</span> ;         <span class="co">// intを代入</span>
    x = <span class="fl">0.0</span> ;       <span class="co">// doubleを代入</span>
    x = <span class="st">&quot;hello&quot;</span>s ;  <span class="co">// std::stringを代入</span>

    <span class="co">// intが入っているか確認</span>
    <span class="co">// falseを返す</span>
    <span class="dt">bool</span> has_int = <span class="bu">std::</span>hold_alternative&lt;<span class="dt">int</span>&gt;( x ) ;
    <span class="co">// std::stringが入っているか確認</span>
    <span class="co">// trueを返す</span>
    <span class="dt">bool</span> has_string = <span class="bu">std::</span>hold_alternative&lt;<span class="bu">std::</span>string&gt; ( x ) ;

    <span class="co">// 入っている値を得る</span>
    <span class="co">// &quot;hello&quot;</span>
    <span class="bu">std::</span>string str = <span class="bu">std::</span>get&lt;<span class="bu">std::</span>string&gt;(x) ;
}</code></pre></div>
<h3 id="型非安全な古典的union">型非安全な古典的union</h3>
<p>C++が従来から持っている古典的なunionは、複数の型のいずれかひとつだけの値を格納する型だ。unionのサイズはデータメンバーのいずれかの型をひとつ表現できるだけのサイズとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">union</span> U
{
    <span class="dt">int</span> i ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string s ;
} ;

<span class="kw">struct</span> S
{
    <span class="dt">int</span> i ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string s ;
}</code></pre></div>
<p>この場合、sizeof(U)のサイズは</p>
<p><span class="math display">\[\text{sizeof(U)} = \max \{ \text{sizeof(int)}, \text{sizeof(double)}, \text{sizeof(std::string)} \} + \text{パディングなど}\]</span></p>
<p>になる。sizeof(S)のサイズは、</p>
<p><span class="math display">\[\text{sizeof(S)} = \text{sizeof(int)} + \text{sizeof(double)} + \text{sizeof(std::string)} + \text{パディングなど}\]</span></p>
<p>になる。</p>
<p>unionはメモリ効率がよい。unionはvariantと違い型非安全だ。どの型の値を保持しているかという情報は保持しないので、利用者が適切に管理しなければならない。</p>
<p>試しに、冒頭のコードをunionで書くと、以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="kw">union</span> U
{
    <span class="dt">int</span> i ;
    <span class="dt">double</span> d ;
    <span class="bu">std::</span>string s ;

    <span class="co">// コンストラクター</span>
    <span class="co">// int型をデフォルト初期化する</span>
    U() : i{} { }
    <span class="co">// デストラクター</span>
    <span class="co">// 何もしない。オブジェクトの破棄は利用者の責任に任せる</span>
    ~U() { }
} ;

<span class="co">// デストラクター呼び出し</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> destruct ( T &amp; x )
{
    x.~T() ;
}

<span class="dt">int</span> main()
{
    U u ;

    <span class="co">// 基本型はそのまま代入できる</span>
    <span class="co">// 破棄も考えなくて良い</span>
    u.i = <span class="dv">0</span> ;
    u.d = <span class="fl">0.0</span> ;

    <span class="co">// 非トリビアルなコンストラクターを持つ型</span>
    <span class="co">// placement newが必要</span>
    <span class="kw">new</span>(&amp;u.s) <span class="bu">std::</span>string(<span class="st">&quot;hello&quot;</span>) ;

    <span class="co">// 利用者はどの型を入れたか別に管理しておく必要がある</span>
    <span class="dt">bool</span> has_int = <span class="kw">false</span> ;
    <span class="dt">bool</span> has_string = <span class="kw">true</span> ;

    <span class="bu">std::</span>cout &lt;&lt; u.s &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ;

    <span class="co">// 非トリビアルなデストラクターを持つ型</span>
    <span class="co">// 破棄が必要</span>
    destruct( u.s ) ;
}</code></pre></div>
<p>このようなコードは書きたくない。variantを使えば、このような面倒で冗長なコードを書かずに、型安全にunionと同等機能を実現できる。</p>
<h3 id="variantの宣言">variantの宣言</h3>
<p>variantはテンプレート実引数で保持したい型を与える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>variant&lt; <span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>, <span class="dt">long</span>&gt; v1 ;
<span class="bu">std::</span>variant&lt;<span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string&gt; v2 ;
<span class="bu">std::</span>variant&lt; <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;. <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; &gt; v3 ;</code></pre></div>
<h3 id="variantの初期化">variantの初期化</h3>
<h4 id="デフォルト初期化">デフォルト初期化</h4>
<p>variantはデフォルト構築すると、最初に与えた型の値をデフォルト構築して保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// int</span>
<span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v1 ;
<span class="co">// double</span>
<span class="bu">std::</span>variant&lt; <span class="dt">double</span>, <span class="dt">int</span> &gt; v2 ;</code></pre></div>
<p>variantにデフォルト構築できない型を最初に与えると、variantもデフォルト構築できない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// デフォルト構築できない型</span>
<span class="kw">struct</span> non_default_constructible
{
    non_default_constructible() = <span class="kw">delete</span> ;
} ;

<span class="co">// エラー</span>
<span class="co">// デフォルト構築できない</span>
<span class="bu">std::</span>variant&lt; non_default_constructible &gt; v ;</code></pre></div>
<p>デフォルト構築できない型だけを保持するvariantをデフォルト構築するためには、最初の型をデフォルト構築可能な型にすればよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> A { A() = <span class="kw">delete</span> ; } ;
<span class="kw">struct</span> B { B() = <span class="kw">delete</span> ; } ;
<span class="kw">struct</span> C { C() = <span class="kw">delete</span> ; } ;

<span class="kw">struct</span> Empty { } ;


<span class="dt">int</span> main()
{
    <span class="co">// OK、Emptyを保持</span>
    <span class="bu">std::</span>variant&lt; Empty, A, B, C &gt; v ;
}</code></pre></div>
<p>このような場合に、Emptyのようなクラスをわざわざ独自に定義するのは面倒なので、標準ライブラリにはstd::monostateクラスが以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
    <span class="kw">struct</span> monostate { } ;
}</code></pre></div>
<p>したがって、上の例は以下のように書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// OK、std::monostateを保持</span>
<span class="bu">std::</span>variant&lt; <span class="bu">std::</span>monostate, A, B, C &gt; v ;</code></pre></div>
<p>std::monostateはvariantの最初のテンプレート実引数として使うことでvariantをデフォルト構築可能にするための型だ。それ以上の意味はない。</p>
<h4 id="コピー初期化">コピー初期化</h4>
<p>variantに同じ型のvariantを渡すと、コピー/ムーブする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; a ;
    <span class="co">// コピー</span>
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; b ( a ) ;
}</code></pre></div>
<h4 id="variantのコンストラクターに値を渡した場合">variantのコンストラクターに値を渡した場合</h4>
<p>variantのコンストラクターに上記以外の値を渡した場合、variantのテンプレート実引数に指定した型の中から、オーバーロード解決により最適な型が選ばれ、その型の値に変換され、値を保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> val = <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; ;

<span class="dt">int</span> main()
{
    <span class="co">// int</span>
    val a(<span class="dv">42</span>) ;
    <span class="co">// double</span>
    val b( <span class="fl">0.0</span> ) ; 

    <span class="co">// std::string</span>
    <span class="co">// char const *型はstd::string型に変換される。</span>
    val c(<span class="st">&quot;hello&quot;</span>) ;

    <span class="co">// int</span>
    <span class="co">// char型はIntegral promotionによりint型に優先的に変換される</span>
    val d( <span class="st">&#39;a&#39;</span> ) ;
}</code></pre></div>
<h4 id="in_place_typeによるemplace構築">in_place_typeによるemplace構築</h4>
<p>variantのコンストラクターの第一引数にstd::in_place_type&lt;T&gt;を渡すことにより、T型の要素を構築するためにT型のコンストラクターに渡す実引数を指定できる。</p>
<p>ほとんどの型はコピーかムーブができる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// Xを構築</span>
    X x( a, b, c ) ;
    <span class="co">// xをコピー</span>
    <span class="bu">std::</span>variant&lt;X&gt; v( x ) ;
}</code></pre></div>
<p>しかし、もし型Xがコピーもムーブもできない型だったとしたら、上記のコードは動かない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
    X( X <span class="at">const</span> &amp; ) = <span class="kw">delete</span> ;
    X( X &amp;&amp; ) = <span class="kw">delete</span> ; 
} ;

<span class="dt">int</span> main()
{
    <span class="co">// Xを構築</span>
    X x( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="co">// エラー、Xはコピーできない</span>
    <span class="bu">std::</span>variant&lt;X&gt; v( x ) ;
}</code></pre></div>
<p>このような場合、variantが内部でXを構築する際に、構築に必要なコンストラクターの実引数を渡して、variantにXを構築させる必要がある。そのためにstd::in_place_type&lt;T&gt;が使える。Tに構築したい型を指定して第一引数とし、第二引数以降をTのコンストラクターに渡す値にする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
    X( X <span class="at">const</span> &amp; ) = <span class="kw">delete</span> ;
    X( X &amp;&amp; ) = <span class="kw">delete</span> ; 
} ;

<span class="dt">int</span> main()
{
    <span class="co">// Xの値を構築して保持</span>
    <span class="bu">std::</span>variant&lt;X&gt; v( <span class="bu">std::</span>in_place_type&lt;X&gt;, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
}</code></pre></div>
<h3 id="variantの破棄">variantの破棄</h3>
<p>variantのデストラクターは、そのときに保持している値を適切に破棄してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;
    <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt; l ;
    <span class="bu">std::</span>deque&lt;<span class="dt">int</span>&gt; d ;
    <span class="bu">std::</span>variant&lt; <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt;, <span class="bu">std::</span>list&lt;<span class="dt">int</span>&gt;, <span class="bu">std::</span>deque&lt;<span class="dt">int</span>&gt; &gt; val ;

    val = v ;
    val = l ;
    val = d ;

    <span class="co">// variantのデストラクターはdeque&lt;int&gt;を破棄する</span>
}</code></pre></div>
<p>variantのユーザーは何もする必要がない。</p>
<h3 id="variantの代入">variantの代入</h3>
<p>variantの代入はとても自然だ。variantを渡せばコピーするし、値を渡せばオーバーロード解決に従って適切な型の値を保持する。</p>
<h3 id="variantのemplace">variantのemplace</h3>
<p>variantはemplaceをサポートしている。variantの場合、構築すべき型を知らせる必要があるので、emplace&lt;T&gt;のTで構築すべき型を指定する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span>, <span class="dt">int</span> ) { }
    X( X <span class="at">const</span> &amp; ) = <span class="kw">delete</span> ;
    X( X &amp;&amp; ) = <span class="kw">delete</span> ; 
} ;

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="bu">std::</span>monostate, X, <span class="bu">std::</span>string&gt; v ;

    <span class="co">// Xを構築</span>
    v.emplace&lt;X&gt;( <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span> ) ;
    <span class="co">// std::stringを構築</span>
    v.emplace&lt; <span class="bu">std::</span>string &gt;( <span class="st">&quot;hello&quot;</span> ) ;
}</code></pre></div>
<h3 id="variantに値が入っているかどうかの確認">variantに値が入っているかどうかの確認</h3>
<h4 id="valueless_by_exceptionメンバー関数">valueless_by_exceptionメンバー関数</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">bool</span> valueless_by_exception() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p>valueless_by_exceptionメンバー関数は、variantが値を保持している場合、falseを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; &amp; v )
{

    <span class="cf">if</span> ( v.valueless_by_exception() ) 
    { <span class="co">// true</span>
        <span class="co">// vは値を保持していない</span>
    }
    { <span class="co">// false</span>
        <span class="co">// vは値を保持している</span>
    }
}</code></pre></div>
<p>variantはどの値も保持しない状態になることがある。例えば、std::stringはコピーにあたって動的なメモリ確保を行うかもしれない。variantがstd::stringをコピーする際に、動的メモリ確保に失敗した場合、コピーは失敗する。なぜならば、variantは別の型の値を構築する前に、以前の値を破棄しなければならないからだ。variantは値を持たない状態になりうる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="bu">std::</span>string &gt; v ;
    <span class="cf">try</span> {
        <span class="bu">std::</span>string s(<span class="st">&quot;hello&quot;</span>) ;
        v = s ; <span class="co">// 動的メモリ確保が発生するかもしれない</span>
    } <span class="cf">catch</span>( <span class="bu">std::</span>bad_alloc e )
    {
    <span class="co">// 動的メモリ確保が失敗するかもしれない</span>
    }

    <span class="co">// 動的メモリ確保の失敗により</span>
    <span class="co">// trueになるかもしれない</span>
    <span class="dt">bool</span> b = v.valueless_by_exception() ;
}</code></pre></div>
<h4 id="indexメンバー関数">indexメンバー関数</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">size_t</span> index() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p>indexメンバー関数は、variantに指定したテンプレート実引数のうち、現在variantが保持している値の型を0ベースのインデックスで返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v ;

    <span class="kw">auto</span> v0 = v.index() ; <span class="co">// 0</span>
    v = <span class="fl">0.0</span> ;
    <span class="kw">auto</span> v1 = v.index() ; <span class="co">// 1</span>
    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="kw">auto</span> v2 = v.index() ; <span class="co">// 2</span>
}</code></pre></div>
<p>もしvariantが値を保持しない場合、つまりvalueless_by_exception()がtrueを返す場合は、std::variant_nposを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// variantが値を持っているかどうか確認する関数</span>
<span class="kw">template</span> &lt; <span class="kw">typename</span> ... Types  &gt;
<span class="dt">void</span> has_value( <span class="bu">std::</span>variant&lt; Types ... &gt; &amp;&amp; v )
{
    <span class="cf">return</span> v.index() != <span class="bu">std::</span>variant_npos ;

    <span class="co">// これでもいい</span>
    <span class="co">// return v.valueless_by_exception() == false ;</span>
}</code></pre></div>
<p>std::variant_nposの値は-1だ。</p>
<h3 id="swap">swap</h3>
<p>variantはswapに対応している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; a, b ;

    a.swap(b) ;
    <span class="bu">std::</span>swap( a, b ) ;
}</code></pre></div>
<h3 id="variant_sizet-variantが保持できる型の数を取得">variant_size&lt;T&gt; : variantが保持できる型の数を取得</h3>
<p>std::variant_size<T>は、Tにvariant型を渡すと、variantが保持できる型の数を返してくれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> t1 = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>&gt; ;
<span class="kw">using</span> t2 = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>&gt; ;
<span class="kw">using</span> t3 = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>&gt; ;

<span class="co">// 1</span>
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t t1_size = <span class="bu">std::</span>variant_size&lt;t1&gt;::size ;
<span class="co">// 2</span>
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t t2_size = <span class="bu">std::</span>variant_size&lt;t2&gt;::size ;
<span class="co">// 3</span>
<span class="kw">constexpr</span> <span class="bu">std::</span>size_t t2_size = <span class="bu">std::</span>variant_size&lt;t3&gt;::size ;</code></pre></div>
<p>variant_sizeはintegral_constantを基本クラスに持つクラスなので、デフォルト構築した結果をユーザー定義変換することでも値を取り出せる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>&gt; ;

<span class="kw">constexpr</span> <span class="bu">std::</span>size_t size = <span class="bu">std::</span>variant_size&lt;type&gt;{} ;</code></pre></div>
<p>variant_sizeを以下のようにラップした変数テンプレートも用意されている</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
    <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> variant_size_v = variant_size&lt;T&gt;::value;</code></pre></div>
<p>これを使えば、以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt;<span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span>&gt; ;

<span class="kw">constexpr</span> <span class="bu">std::</span>size_t size = <span class="bu">std::</span>variant_size_v&lt;type&gt; ;</code></pre></div>
<h3 id="variant_alternativei-t-インデックスから型を返す">variant_alternative&lt;I, T&gt; : インデックスから型を返す</h3>
<p>std::variant_alternative&lt;I, T&gt;はT型のvariantの保持できる型のうち、I番目の型をネストされた型名typeで返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt; <span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span> &gt; ;

<span class="co">// char</span>
<span class="kw">using</span> t0 = <span class="bu">std::</span>variant_alternative&lt;<span class="dv">0</span>, type &gt;::type ;
<span class="co">// short</span>
<span class="kw">using</span> t1 = <span class="bu">std::</span>variant_alternative&lt;<span class="dv">1</span>, type &gt;::type ;
<span class="co">// ing</span>
<span class="kw">using</span> t2 = <span class="bu">std::</span>variant_alternative&lt;<span class="dv">2</span>, type &gt;::type ;</code></pre></div>
<p>variant_alternative_tというテンプレートエイリアスが以下のように定義されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="dt">size_t</span> I, <span class="kw">class</span> T&gt;
    <span class="kw">using</span> <span class="dt">variant_alternative_t</span> = <span class="kw">typename</span> variant_alternative&lt;I, T&gt;::type;</code></pre></div>
<p>これをつかえば、以下のようにも書ける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">using</span> type = <span class="bu">std::</span>variant&lt; <span class="dt">char</span>, <span class="dt">short</span>, <span class="dt">int</span> &gt; ;

<span class="co">// char</span>
<span class="kw">using</span> t0 = <span class="bu">std::</span>variant_alternative_t&lt;<span class="dv">0</span>, type &gt; ;
<span class="co">// short</span>
<span class="kw">using</span> t1 = <span class="bu">std::</span>variant_alternative_t&lt;<span class="dv">1</span>, type &gt; ;
<span class="co">// ing</span>
<span class="kw">using</span> t2 = <span class="bu">std::</span>variant_alternative_t&lt;<span class="dv">2</span>, type &gt; ;</code></pre></div>
<h3 id="holds_alternative-variantが指定した型の値を保持しているかどうかの確認">holds_alternative : variantが指定した型の値を保持しているかどうかの確認</h3>
<p>holds_alternative&lt;T&gt;(v)は、variant vがT型の値を保持しているかどうかを確認する。保持しているのであればtrueを、そうでなければfalseを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を構築</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v ;

    <span class="co">// true</span>
    <span class="dt">bool</span> has_int = <span class="bu">std::</span>holds_alternative&lt;<span class="dt">int</span>&gt;(v) ;
    <span class="co">// false</span>
    <span class="dt">bool</span> has_double = <span class="bu">std::</span>holds_alternative&lt;<span class="dt">double</span>&gt;(v) ;
}</code></pre></div>
<p>型Tは実引数に与えられたvariantが保持できる型でなければならない。以下のようなコードはエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; v ;

    <span class="co">// エラー</span>
    <span class="bu">std::</span>holds_alternative&lt;<span class="dt">double</span>&gt;(v) ;
}</code></pre></div>
<h3 id="getiv-インデックスから値の取得">get&lt;I&gt;(v) : インデックスから値の取得</h3>
<p>get&lt;I&gt;(v)は、variant vの型のインデックスからI番目の型の値を返す。インデックスは0ベースだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 0: int</span>
    <span class="co">// 1: double</span>
    <span class="co">// 2: std::string</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v(<span class="dv">42</span>) ;

    <span class="co">// int, 42</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(v) ;

    v = <span class="fl">3.14</span> ;
    <span class="co">// double, 3.14</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(v) ;

    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="co">// std::string, &quot;hello&quot;</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>get&lt;<span class="dv">2</span>&gt;(v) ;
}</code></pre></div>
<p>Iがインデックスの範囲を超えているとエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// インデックスは0, 1, 2まで</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v ;

    <span class="co">// エラー、範囲外</span>
    <span class="bu">std::</span>get&lt;<span class="dv">3</span>&gt;(v) ;
}</code></pre></div>
<p>もし、variantが値を保持していない場合、つまりv.index() != Iの場合は、std::bad_variant_accessがthrowされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v( <span class="dv">42</span> ) ;

    <span class="cf">try</span> {
        <span class="co">// double型の値を要求</span>
        <span class="kw">auto</span> d = <span class="bu">std::</span>get&lt;<span class="dv">1</span>&gt;(v) ;
    } <span class="cf">catch</span> ( <span class="bu">std::</span>bad_variant_access &amp; e )
    {
        <span class="co">// doubleは保持していなかった</span>
    }
}</code></pre></div>
<p>getの実引数に渡すvariantがlvalueの場合は、戻り値はlvalueリファレンス、rvalueの場合は戻り値はrvalueリファレンスになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; v ;

    <span class="co">// int &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;(v) ;
    <span class="co">// int &amp;&amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) b = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( <span class="bu">std::</span>move(v) ) ;
}</code></pre></div>
<p>getの実引数に渡すvariantがCV修飾されている場合、戻り値の型も実引数と同じくCV修飾される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; <span class="at">const</span> cv ;
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; <span class="at">volatile</span> vv ;
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span> &gt; <span class="at">const</span> <span class="at">volatile</span> cvv ;

    <span class="co">// int const &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) a = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( cv ) ;
    <span class="co">// int volatile &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) b = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( vv ) ;
    <span class="co">// int const volatile &amp;</span>
    <span class="kw">decltype</span>(<span class="kw">auto</span>) c = <span class="bu">std::</span>get&lt;<span class="dv">0</span>&gt;( cvv ) ;
}</code></pre></div>
<h3 id="gettv-型から値の取得">get&lt;T&gt;(v) : 型から値の取得</h3>
<p>get&lt;T&gt;(v)は、variant vの保有する型Tの値を返す。型Tの値を保持していない場合、std::bad_variant_accessがthrowされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string &gt; v( <span class="dv">42</span> ) ;

    <span class="co">// int</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get&lt;<span class="dt">int</span>&gt;( v ) ;

    v = <span class="fl">3.14</span>
    <span class="co">// double</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>get&lt;<span class="dt">double</span>&gt;( v ) ;

    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="co">// std::string</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>get&lt;<span class="bu">std::</span>string&gt;( v ) ;
}</code></pre></div>
<p>その他はすべてget&lt;I&gt;と同じ。</p>
<h3 id="get_if-値を保持している場合に取得">get_if : 値を保持している場合に取得</h3>
<p>get_if&lt;I&gt;(vp)とget_if&lt;T&gt;(vp)は、variantへのポインターvpを実引数にとり、*vpがインデックスI、もしくは型Tの値を保持している場合、その値へのポインターを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span>, <span class="bu">std::</span>string&gt; v( <span class="dv">42</span> ) ;

    <span class="co">// int *</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get_if&lt;<span class="dt">int</span>&gt;( &amp;v ) ; 

    v = <span class="fl">3.14</span> ;
    <span class="co">// double *</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>get_if&lt;<span class="dv">1</span>&gt;( &amp;v ) ;

    v = <span class="st">&quot;hello&quot;</span> ;
    <span class="co">// std::string</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>get_if&lt;<span class="dv">2</span>&gt;( &amp;v ) ;

}</code></pre></div>
<p>もし、vpがnullptrの場合、もしくは*vpが指定された値を保持していない場合は、nullptrを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持</span>
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; v( <span class="dv">42</span> ) ;

    <span class="co">// nullptr</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get_if&lt;<span class="dt">int</span>&gt;( <span class="kw">nullptr</span> ) ;

    <span class="co">// nullptr</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>get_if&lt;<span class="dt">double</span>&gt;( &amp;v ) ;
}</code></pre></div>
<h3 id="variantの比較">variantの比較</h3>
<p>variantは比較演算子がオーバーロードされているため比較できる。variant同士の比較は、一般のプログラマーは自然だと思う結果になるように実装されている。</p>
<h4 id="同一性の比較">同一性の比較</h4>
<p>variantの同一性の比較のためには、variantのテンプレート実引数に与える型は自分自身と比較可能でなければならない。</p>
<p>つまり、variant v, wに対して、式 get&lt;i&gt;(v) == get&lt;i&gt;(w) がすべてのiに対して妥当でなければならない。</p>
<p>variant v, wの同一性の比較は、v == w の場合、以下のように行われる。</p>
<ol style="list-style-type: decimal">
<li>v.index() != v.indexならば、false</li>
<li>それ以外の場合、v.value_less_by_exception()ならば、true</li>
<li>それ以外の場合、get&lt;i&gt;(v) == get&lt;i&gt;(w)。ただしiはv.index()</li>
</ol>
<p>二つのvariantが別の型を保持している場合は等しくない。ともに値なしの状態であれば等しい。それ以外は保持している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; a(<span class="dv">0</span>), b(<span class="dv">0</span>) ;

    <span class="co">// true</span>
    <span class="co">// 同じ型の同じ値を保持している。</span>
    a == b ;

    a = <span class="fl">1.0</span> ;

    <span class="co">// false</span>
    <span class="co">// 型が違う</span>
    a == b ;
}</code></pre></div>
<p>例えばoperator ==は以下のような実装になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span>... Types&gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span> == (<span class="at">const</span> variant&lt;Types...&gt;&amp; v, <span class="at">const</span> variant&lt;Types...&gt;&amp; w)
{
    <span class="cf">if</span> ( v.index() != w.index() )
        <span class="cf">return</span> <span class="kw">false</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.valueless_by_exception() )
        <span class="cf">return</span> <span class="kw">true</span> ;
    <span class="cf">else</span>
        <span class="cf">return</span> <span class="bu">std::</span>visit( []( <span class="kw">auto</span> &amp;&amp; a, <span class="kw">auto</span> &amp;&amp; b ){ <span class="cf">return</span> a == b ; }, v, w ) ;
}</code></pre></div>
<p>operator !=はこの逆だと考えてよい。</p>
<h4 id="大小比較">大小比較</h4>
<p>variantの大小の比較のためには、variantのテンプレート実引数に与える型は自分自身と比較可能でなければならない。</p>
<p>つまり、operator &lt; の場合、variant v, wに対して、式 get&lt;i&gt;(v) &lt; get&lt;i&gt;(w) がすべてのiに対して妥当でなければならない。</p>
<p>variant v, wの大小比較は、v &lt; w の場合、以下のように行われる。</p>
<ol style="list-style-type: decimal">
<li>w.valueless_by_exception()ならば、false</li>
<li>それ以外の場合、v.valueless_by_exception()ならば、true</li>
<li>それ以外の場合、v.index() &lt; w.index()ならば、true</li>
<li>それ以外の場合、v.index &gt; w.index()ならば、false</li>
<li>それ以外の場合、get&lt;i&gt;(v) &lt; get&lt;i&gt;(w)。ただしiはv.index()</li>
</ol>
<p>値なしのvariantは最も小さいとみなされる。インデックスの小さいほうが小さいとみなされる。どちらも同じ型の値があるのであれば、値同士の比較となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt; <span class="dt">int</span>, <span class="dt">double</span> &gt; a(<span class="dv">0</span>), b(<span class="dv">0</span>) ;

    <span class="co">// false</span>
    <span class="co">// 同じ型の同じ値を比較</span>
    a &lt; b ;

    a = <span class="fl">1.0</span> ;

    <span class="co">// false</span>
    <span class="co">// インデックスによる比較</span>
    a &lt; b ;
    <span class="co">// true</span>
    <span class="co">// インデックスによる比較</span>
    b &lt; a ;
}</code></pre></div>
<p>operator &lt;は以下のような実装になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span>... Types&gt;
<span class="kw">constexpr</span> <span class="dt">bool</span> <span class="kw">operator</span>&lt;(<span class="at">const</span> variant&lt;Types...&gt;&amp; v, <span class="at">const</span> variant&lt;Types...&gt;&amp; w)
{
    <span class="cf">if</span> ( w.valueless_by_exception() )
        <span class="cf">return</span> <span class="kw">false</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.valueless_by_exception() )
        <span class="cf">return</span> <span class="kw">true</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.index() &lt; w.index() )
        <span class="cf">return</span> <span class="kw">true</span> ;
    <span class="cf">else</span> <span class="cf">if</span> ( v.index &gt; w.index() )
        <span class="cf">return</span> <span class="kw">false</span> ;
    <span class="cf">else</span>
        <span class="cf">return</span> <span class="bu">std::</span>visit( []( <span class="kw">auto</span> &amp;&amp; a, <span class="kw">auto</span> &amp;&amp; b ){ <span class="cf">return</span> a &lt; b ; }, v, w ) ;
}</code></pre></div>
<p>残りの大小比較も同じ方法で比較される。</p>
<h3 id="visit-variantが保持している値を受け取る">visit : variantが保持している値を受け取る。</h3>
<p>std::visitは、variantの保持している型を実引数に関数オブジェクトを呼んでくれるライブラリだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> val = <span class="bu">std::</span>variant&lt;<span class="dt">int</span>, <span class="dt">double</span>&gt; ;

    val v(<span class="dv">42</span>) ;
    val w(<span class="fl">3.14</span>) ;

    <span class="kw">auto</span> visitor = []( <span class="kw">auto</span> a, <span class="kw">auto</span> b ) { <span class="bu">std::</span>cout &lt;&lt; a &lt;&lt; b &lt;&lt; <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span> ; } ;

    <span class="co">// visitor( 42, 3.14 )が呼ばれる</span>
    <span class="bu">std::</span>visit( visitor, v, w ) ;
    <span class="co">// visitor( 3.14, 42 ) が呼ばれる</span>
    <span class="bu">std::</span>visit( visitor, w, v ) ;
}</code></pre></div>
<p>このように、variantにどの型の値が保持されていても扱うことができる。</p>
<p>std::visitは以下のように宣言されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">class</span> Visitor, <span class="kw">class</span>... Variants &gt;
<span class="kw">constexpr</span> <span class="kw">auto</span> visit( Visitor&amp;&amp; vis, Variants&amp;&amp;... vars ) ;</code></pre></div>
<p>第一引数に関数オブジェクトを渡し、第二引数以降にvariantを渡す。すると、vis( get&lt;i&gt;(vars)... )のように呼ばれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>variant&lt;<span class="dt">int</span>&gt; a(<span class="dv">1</span>), b(<span class="dv">2</span>), c(<span class="dv">3</span>) ;

    <span class="co">// ( 1 ) </span>
    <span class="bu">std::</span>visit( []( <span class="kw">auto</span> x ) {}, a ) ;

    <span class="co">// ( 1, 2, 3 )</span>
    <span class="bu">std::</span>visit( []( <span class="kw">auto</span> x, <span class="kw">auto</span> y, <span class="kw">auto</span> z ) {}, a, b, c ) ;
}</code></pre></div>
<h2 id="any-どんな型の値でも保持できるクラス">any : どんな型の値でも保持できるクラス</h2>
<h3 id="使い方-1">使い方</h3>
<p>ヘッダーファイル&lt;any&gt;で定義されているstd::anyは、ほとんどどんな型の値でも保持できるクラスだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="pp">#include </span><span class="im">&lt;any&gt;</span>

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    a = <span class="dv">0</span> ; <span class="co">// int</span>
    a = <span class="fl">1.0</span> ; <span class="co">// double</span>
    a = <span class="st">&quot;hello&quot;</span> ; <span class="co">// char const *</span>

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; v ;
    a = v ; <span class="co">// std::vector&lt;int&gt;</span>

    <span class="co">// 保持しているstd::vector&lt;int&gt;のコピー</span>
    <span class="kw">auto</span> value = <span class="bu">std::</span>any_cast&lt; <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; &gt;( a ) ;
}</code></pre></div>
<p>anyが保持できない型は、コピー構築できない型だ。</p>
<h3 id="anyの構築と破棄">anyの構築と破棄</h3>
<p>クラスanyはテンプレートではない。そのため宣言は単純だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 値を保持しない</span>
    <span class="bu">std::</span>any a ;
    <span class="co">// int型の値を保持する</span>
    <span class="bu">std::</span>any b( <span class="dv">0</span> ) ;
    <span class="co">// double型の値を保持する</span>
    <span class="bu">std::</span>any c( <span class="fl">0.0</span> ) ;
}</code></pre></div>
<p>anyが保持する型を事前に指定する必要はない。</p>
<p>クラスanyを破棄すると、その時保持していた値が適切に破棄される。</p>
<h3 id="in_place_typeコンストラクター">in_place_typeコンストラクター</h3>
<p>anyのコンストラクターでemplaceをするためにin_place_typeが使える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// 型XをX(1, 2)で構築した結果の値を保持する</span>
    <span class="bu">std::</span>any a( <span class="bu">std::</span>in_place_type&lt;X&gt;, <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h3 id="anyへの代入">anyへの代入</h3>
<p>anyへの代入も普通のプログラマーの期待通りの動きをする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;
    <span class="bu">std::</span>any b ;

    <span class="co">// aはint型の値42を保持する。</span>
    a = <span class="dv">42</span> ;
    <span class="co">// bはint型の値42を保持する</span>
    b = a ;
    
}</code></pre></div>
<h3 id="anyのメンバー関数">anyのメンバー関数</h3>
<h4 id="emplace">emplace</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span>... Args&gt;
<span class="dt">decay_t</span>&lt;T&gt;&amp; emplace(Args&amp;&amp;... args);</code></pre></div>
<p>anyはemplaceメンバー関数をサポートしている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    <span class="co">// 型XをX(1, 2)で構築した結果の値を保持する</span>
    a.emplace( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h4 id="reset-値の破棄">reset : 値の破棄</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> reset() <span class="kw">noexcept</span> ; </code></pre></div>
<p>anyのresetメンバー関数は、anyの保持してある値を破棄する。resetを呼び出した後のanyは値を保持しない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// aは値を保持しない</span>
    <span class="bu">std::</span>any a ;
    <span class="co">// aはint型の値を保持する</span>
    a = <span class="dv">0</span> ;

    <span class="co">// aは値を保持しない</span>
    a.reset() ;
}</code></pre></div>
<h4 id="swap-スワップ">swap : スワップ</h4>
<p>anyはswapメンバー関数をサポートしている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a(<span class="dv">0</span>) ;
    <span class="bu">std::</span>any b(<span class="fl">0.0</span>) ;

    <span class="co">// aはint型の値を保持</span>
    <span class="co">// bはdouble型の値を保持</span>

    a.swap(b) ;

    <span class="co">// aはdouble型の値を保持</span>
    <span class="co">// bはint型の値を保持。</span>
}</code></pre></div>
<h4 id="has_value-値を保持しているかどうか調べる">has_value : 値を保持しているかどうか調べる</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">bool</span> has_value() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p>anyのhas_valueメンバー関数はanyが値を保持しているかどうかを調べる。値を保持しているならばtrueを、保持していないならばfalseを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    <span class="co">// false</span>
    <span class="dt">bool</span> b1 = a.has_value() ;

    a = <span class="dv">0</span> ;
    <span class="co">// true</span>
    <span class="dt">bool</span> b2 = a.has_value() ;

    a.reset() ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b3 = a.has_value() ;
}</code></pre></div>
<h4 id="type-保持している型のtype_infoを得る">type : 保持している型のtype_infoを得る</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="at">const</span> type_info&amp; type() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p>typeメンバー関数は、保持している型Tのtypeid(T)を返す。値を保持していない場合、typeid(void)を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a ;

    <span class="co">// typeid(void)</span>
    <span class="kw">auto</span> &amp; t1 = a.type() ;

    a = <span class="dv">0</span> ;
    <span class="co">// typeid(int)</span>
    <span class="kw">auto</span> &amp; t2 = a.type() ;

    a = <span class="fl">0.0</span> ;
    <span class="co">// typeid(double)</span>
    <span class="kw">auto</span> &amp; t3 = a.type() ;
}</code></pre></div>
<h3 id="anyのフリー関数">anyのフリー関数</h3>
<h4 id="make_anyt-t型のanyを作る">make_any&lt;T&gt; : T型のanyを作る</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">emplate &lt;<span class="kw">class</span> T, <span class="kw">class</span>... Args&gt;
any make_any(Args&amp;&amp; ...args);

<span class="kw">template</span> &lt;<span class="kw">class</span> T, <span class="kw">class</span> U, <span class="kw">class</span>... Args&gt;
any make_any(initializer_list&lt;U&gt; il, Args&amp;&amp; ...args);</code></pre></div>
<p>make_any&lt;T&gt;( args... )はT型をコンストラクター実引数args...で構築した値を保持するanyを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持するany</span>
    <span class="kw">auto</span> a = <span class="bu">std::</span>make_any&lt;<span class="dt">int</span>&gt;( <span class="dv">0</span> ) ;
    <span class="co">// double型の値を保持するany</span>
    <span class="kw">auto</span> b = <span class="bu">std::</span>make_any&lt;<span class="dt">double</span>&gt;( <span class="fl">0.0</span> ) ;

    <span class="co">// X型の値を保持するany</span>
    <span class="kw">auto</span> c = <span class="bu">std::</span>make_any&lt;X&gt;( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h4 id="any_cast-保持している値の取り出し">any_cast : 保持している値の取り出し</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; T any_cast(<span class="at">const</span> any&amp; operand);
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; T any_cast(any&amp; operand);
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; T any_cast(any&amp;&amp; operand);</code></pre></div>
<p>any_cast&lt;T&gt;(operand)はoperandが保持している値を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a(<span class="dv">0</span>) ;

    <span class="dt">int</span> value = <span class="bu">std::</span>any_cast&lt;<span class="dt">int</span>&gt;(a) ;
}</code></pre></div>
<p>any_cast&lt;T&gt;で指定したT型が、anyが保持している型ではない場合、std::bad_any_castがthrowされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="cf">try</span> {
        <span class="bu">std::</span>any a ;
        <span class="bu">std::</span>any_cast&lt;<span class="dt">int</span>&gt;(a) ;
    } <span class="cf">catch</span>( <span class="bu">std::</span>bad_any_cast e )
    {
        <span class="co">// 型を保持していなかった。</span>
    }

}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
<span class="at">const</span> T* any_cast(<span class="at">const</span> any* operand) <span class="kw">noexcept</span>;
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt;
T* any_cast(any* operand) <span class="kw">noexcept</span>;</code></pre></div>
<p>any_cast&lt;T&gt;にanyへのポインターを渡すと、Tへのポインター型が返される。anyがT型を保持している場合はT型を参照するポインターが返る。保持していない場合は、nullptrが返る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>any a(<span class="dv">42</span>) ;

    <span class="co">// int型の値を参照するポインター</span>
    <span class="dt">int</span> * p1 = <span class="bu">std::</span>any_cast&lt;<span class="dt">int</span>&gt;( &amp;a ) ;

    <span class="co">// nullptr</span>
    <span class="dt">double</span> * p2 = <span class="bu">std::</span>any_Cast&lt;<span class="dt">double</span>&gt;( &amp;a ) ;
}</code></pre></div>
<h2 id="optional-値を保有しているかしていないクラス">optional : 値を保有しているか、していないクラス</h2>
<h3 id="使い方-2">使い方</h3>
<p>ヘッダーファイル&lt;optional&gt;で定義されているoptional&lt;T&gt;は、T型の値を保有しているか、保有していないライブラリだ。</p>
<p>条件次第で値が用意できない場合が存在する。例えば割り算の結果の値を返す関数を考える。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> divide( <span class="dt">int</span> a, <span class="dt">int</span> b )
{
    <span class="cf">if</span> ( b == <span class="dv">0</span> )
    {
        <span class="co">// エラー処理</span>
    }
    <span class="cf">else</span>
        <span class="cf">return</span> a / b ;
}</code></pre></div>
<p>ゼロで除算はできないので、bの値が0の場合、この関数は値を用意することができない。問題は、int型のすべての値は通常の除算結果として使われるので、エラーであることを示す特別な値を返すこともできない。</p>
<p>このような場合にエラーや値を通知する方法として、過去に様々な方法が考案された。例えば、ポインターやリファレンスを実引数として受け取る方法、グローバル変数を使う方法、例外だ。</p>
<p>optionalはこのような値が用意できない場合に使える共通の方法を提供する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; divide( <span class="dt">int</span> a, <span class="dt">int</span> b )
{
    <span class="cf">if</span> ( b == <span class="dv">0</span> )
        <span class="cf">return</span> {} ;
    <span class="cf">else</span>
        <span class="cf">return</span> { a / b } ;
}

<span class="dt">int</span> main()
{
    <span class="kw">auto</span> result = divide( <span class="dv">10</span>, <span class="dv">2</span> ) ;
    <span class="co">// 値の取得</span>
    <span class="kw">auto</span> value = result.value() ;

    <span class="co">// ゼロ除算</span>
    <span class="kw">auto</span> fail = divide( <span class="dv">10</span>, <span class="dv">0</span> ) ;

    <span class="co">// false、値を保持していない</span>
    <span class="dt">bool</span> has_value = fail.has_value() ;

    <span class="co">// throw bad_optional_access</span>
    <span class="kw">auto</span> get_value_anyway = fail.value() ;
}</code></pre></div>
<h3 id="optionalのテンプレート実引数">optionalのテンプレート実引数</h3>
<p>optional&lt;T&gt;はT型の値を保持するか、もしくは保持しない状態を取る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値を保持するかしないoptional</span>
    <span class="kw">using</span> a = <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; ;
    <span class="co">// double型の値を保持するかしないottional</span>
    <span class="kw">using</span> b = <span class="bu">std::</span>optional&lt;<span class="dt">double</span>&gt; ;
}</code></pre></div>
<h3 id="optionalの構築">optionalの構築</h3>
<p>optionalをデフォルト構築すると、値を保持しないoptionalになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 値を保持しない</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a ;
}</code></pre></div>
<p>コンストラクターの実引数にstd::nulloptを渡すと、値を保持しないoptionalになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 値を保持しない</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="bu">std::</span>nullopt ) ;
}</code></pre></div>
<p>optional&lt;T&gt;のコンストラクターの実引数にT型に変換できる型を渡すと、T型の値に型変換して保持する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値42を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a(<span class="dv">42</span>) ;

    <span class="co">// double型の値1.0を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">double</span>&gt; b( <span class="fl">1.0</span> ) ;

    <span class="co">// intからdoubleへの型変換が行われる</span>
    <span class="co">// int型の値1を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; c ( <span class="fl">1.0</span> ) ;
}</code></pre></div>
<p>T型からU型に型変換できるとき、optional&lt;T&gt;のコンストラクターにoptional&lt;U&gt;を渡すとUからTに型変換されてT型の値を保持するoptionalになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// int型の値42を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="dv">42</span> ) ;

    <span class="co">// long型の値42を保持する</span>
    <span class="bu">std::</span>optional&lt;<span class="dt">long</span>&gt; b ( a ) ;
}</code></pre></div>
<p>optionalのコンストラクターの第一引数にstd::in_place_type&lt;T&gt;を渡すと、後続の引数を使ってT型のオブジェクトがemplace構築される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// X(1, 2)</span>
    <span class="bu">std::</span>optional&lt;X&gt; o( <span class="bu">std::</span>in_place_type&lt;X&gt;, <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h3 id="optionalの代入">optionalの代入</h3>
<p>通常のプログラマーの期待通りの挙動をする。std::nulloptを代入すると値を保持しないoptionalになる。</p>
<h3 id="optionalの破棄">optionalの破棄</h3>
<p>optionalが破棄されるとき、保持している値があれば、適切に破棄される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    ~X() { }
} ;

<span class="dt">int</span> main()
{
    {
        <span class="co">// 値を保持する</span>
        <span class="bu">std::</span>optional&lt;X&gt; o ( X{} ) ;
        <span class="co">// Xのデストラクターが呼ばれる。</span>
    }

    {
        <span class="co">// 値を保持しない</span>
        <span class="bu">std::</span>optional&lt;X&gt; o ;
        <span class="co">// Xのデストラクターは呼ばれない。</span>
    }   
}</code></pre></div>
<h3 id="swap-1">swap</h3>
<p>optionalはswapに対応している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a(<span class="dv">1</span>), b(<span class="dv">2</span>) ;

    a.swap(b) ;
}</code></pre></div>
<h3 id="has_value-値を保持しているかどうか確認する">has_value : 値を保持しているかどうか確認する</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">bool</span> has_value() <span class="at">const</span> <span class="kw">noexcept</span>;</code></pre></div>
<p>has_valueメンバー関数はoptionalが値を保持している場合、trueを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a ;
    <span class="co">// false</span>
    <span class="dt">bool</span> b1 = a.has_value() ;

    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; b(<span class="dv">42</span>) ;
    <span class="co">// true</span>
    <span class="dt">bool</span> b2 = b.has_value() ;
}</code></pre></div>
<h3 id="value-保持している値を取得">value : 保持している値を取得</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="at">const</span> T&amp; value() <span class="at">const</span>&amp;;
<span class="kw">constexpr</span> T&amp; value() &amp;;
<span class="kw">constexpr</span> T&amp;&amp; value() &amp;&amp;;
<span class="kw">constexpr</span> <span class="at">const</span> T&amp;&amp; value() <span class="at">const</span>&amp;&amp;;</code></pre></div>
<p>valueメンバー関数はoptionalが値を保持している場合、値へのリファレンスを返す。値を保持していない場合、std::bad_optional_accessがthrowされる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a(<span class="dv">42</span>) ;

    <span class="co">// OK</span>
    <span class="dt">int</span> x = a.value () ;

    <span class="cf">try</span> {
        <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; b ;
        <span class="dt">int</span> y = b.get() ;
    } <span class="cf">catch</span>( <span class="bu">std::</span>bad_optional_access e )
    {
        <span class="co">// 値を保持していなかった</span>
    }
}</code></pre></div>
<h3 id="value_or-値もしくはデフォルト値を返す">value_or : 値もしくはデフォルト値を返す</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> U&gt; <span class="kw">constexpr</span> T value_or(U&amp;&amp; v) <span class="at">const</span>&amp;;
<span class="kw">template</span> &lt;<span class="kw">class</span> U&gt; <span class="kw">constexpr</span> T value_or(U&amp;&amp; v) &amp;&amp;;</code></pre></div>
<p>value_or(v)メンバー関数は、optionalが値を保持している場合はその値を、保持していない場合はvを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="dv">42</span> ) ;

    <span class="co">// 42</span>
    <span class="dt">int</span> x = a.value_or(<span class="dv">0</span>) ;

    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; b ;

    <span class="co">// 0</span>
    <span class="dt">int</span> x = b.value_or(<span class="dv">0</span>) ;
}</code></pre></div>
<h3 id="reset-保持している値を破棄する">reset : 保持している値を破棄する</h3>
<p>resetメンバー関数を呼び出すと、保持している値がある場合破棄する。resetメンバー関数を呼び出した後のoptionalは値を保持しない状態になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a( <span class="dv">42</span> ) ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b1 = a.has_value() ;

    a.reset() ;

    <span class="co">// false</span>
    <span class="dt">bool</span> b2 = a.has_value() ;
}</code></pre></div>
<h3 id="optional同士の比較">optional同士の比較</h3>
<p>optional&lt;T&gt;を比較するためには、T型のオブジェクト同士が比較できる必要がある。</p>
<h4 id="同一性の比較-1">同一性の比較</h4>
<p>値を保持しない二つのoptionalは等しい。片方のみが値を保持しているoptionalは等しくない。両方とも値を保持しているoptionalは値による比較になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a, b ;

    <span class="co">// true</span>
    <span class="co">// どちらも値を保持しないoptional</span>
    <span class="dt">bool</span> b1 a == b ;

    a = <span class="dv">0</span> ;

    <span class="co">// false</span>
    <span class="co">// aのみ値を保持</span>
    <span class="dt">bool</span> b2 = a == b ;

    b = <span class="dv">1</span> ;

    <span class="co">// false</span>
    <span class="co">// どちらも値を保持。値による比較</span>
    <span class="dt">bool</span> b3 = a == b ;
}</code></pre></div>
<h4 id="大小比較-1">大小比較</h4>
<p>optional同士の大小比較は、a &lt; bの場合</p>
<ol style="list-style-type: decimal">
<li>bが値を保持していなければfalse</li>
<li>それ以外の場合で、aが値を保持していなければtrue</li>
<li>それ以外の場合、aとbの保持している値同士の比較</li>
</ol>
<p>となる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>optional&lt;<span class="dt">int</span>&gt; a, b ;

    <span class="co">// false</span>
    <span class="co">// bが値なし</span>
    <span class="dt">bool</span> b1 = a &lt; b ;

    b = <span class="dv">0</span> ;

    <span class="co">// true</span>
    <span class="co">// bは値ありでaが値なし</span>
    <span class="dt">bool</span> b2 = a &lt; b ;

    a = <span class="dv">1</span> ;

    <span class="co">// false</span>
    <span class="co">// どちらとも値があるので値同士の比較</span>
    <span class="co">// 1 &lt; 0はfalse</span>
    <span class="dt">bool</span> b3 = a &lt; b ;
}</code></pre></div>
<h3 id="optionalとstdnullpotとの比較">optionalとstd::nullpotとの比較</h3>
<p>optionalとstd::nulloptとの比較は、std::nulloptが値を持っていないoptionalとして扱われる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"></code></pre></div>
<h3 id="optionaltとtの比較">optional&lt;T&gt;とTの比較</h3>
<p>optional&lt;T&gt;とT型の比較をする場合、optionalは値を保持していなければならない。</p>
<h3 id="make_optionalt-optionaltを返す">make_optional&lt;T&gt; : optional&lt;T&gt;を返す</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">constexpr</span> optional&lt;<span class="dt">decay_t</span>&lt;T&gt;&gt; make_optional(T&amp;&amp; v);</code></pre></div>
<p>make_optional&lt;T&gt;(T t)はoptional&lt;T&gt;(t)を返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// std::optional&lt;int&gt;、値は0</span>
    <span class="kw">auto</span> o1 = <span class="bu">std::</span>make_optional( <span class="dv">0</span> ) ;

    <span class="co">// std::optional&lt;double&gt;、値は0.0</span>
    <span class="kw">auto</span> o2 = <span class="bu">std::</span>make_optional( <span class="fl">0.0</span> ) ;
}</code></pre></div>
<h3 id="make_optionalt-args-...-optionaltをin_place_type構築して返す">make_optional&lt;T, Args ... &gt; : optional&lt;T&gt;をin_place_type構築して返す</h3>
<p>make_optionalの第一引数がT型ではない場合、in_place_type構築するオーバーロード関数が選ばれる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">struct</span> X
{
    X( <span class="dt">int</span>, <span class="dt">int</span> ) { }
} ;

<span class="dt">int</span> main()
{
    <span class="co">// std::optional&lt;X&gt;( std::in_place_type&lt;X&gt;, 1, 2 )</span>
    <span class="kw">auto</span> o = <span class="bu">std::</span>make_optional&lt;X&gt;( <span class="dv">1</span>, <span class="dv">2</span> ) ;
}</code></pre></div>
<h1 id="string_view-文字列ラッパー">string_view : 文字列ラッパー</h1>
<p>string_viewは、文字型(char, wchar_t, char16_t, char32_t)の連続した配列で表現された文字列に対する共通の文字列ビューを提供する。文字列は所有しない。</p>
<h2 id="使い方-3">使い方</h2>
<p>連続した文字型の配列を使った文字列の表現方法には様々ある。C++では最も基本的な文字列の表現方法として、null終端された文字型の配列がある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">char</span> str[<span class="dv">6</span>] = { <span class="st">&#39;h&#39;</span>, <span class="st">&#39;e&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;o&#39;</span>, <span class="st">&#39;</span><span class="sc">\0</span><span class="st">&#39;</span>} ;</code></pre></div>
<p>あるいは、文字型の配列と文字数で表現することもある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// sizeは文字数</span>
<span class="bu">std::</span>size_t size
<span class="dt">char</span> * ptr ;</code></pre></div>
<p>このような表現をいちいち管理するのは面倒なので、クラスで包むこともある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> <span class="dt">string_type</span>
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> *ptr
} ;</code></pre></div>
<p>このように文字列を表現する方法は様々ある。これらのすべてに対応していると、表現の数だけ関数のオーバーロードが追加されていくことになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// null終端文字列用</span>
<span class="dt">void</span> process_string( <span class="dt">char</span> * ptr ) ;
<span class="co">// 配列へのポインターと文字数</span>
<span class="dt">void</span> process_string( <span class="dt">char</span> * ptr, <span class="bu">std::</span>size_t size ) ;
<span class="co">// std::stringクラス</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string s ) ;
<span class="co">// 自作のstring_typeクラス</span>
<span class="dt">void</span> process_string( <span class="dt">string_type</span> s ) ;
<span class="co">// 自作のmy_string_typeクラス</span>
<span class="dt">void</span> process_string( <span class="dt">my_string_type</span> s ) ;</code></pre></div>
<p>string_viewは様々な表現の文字列に対して共通のviewを提供することで、この問題を解決できる。もう関数のオーバーロードを大量に追加する必要はない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 自作のstring_type</span>
<span class="kw">struct</span> <span class="dt">string_type</span>
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> * ptr ;

    <span class="co">// string_viewに対応する変換関数</span>
    <span class="kw">operator</span> <span class="bu">std::</span>string_view() <span class="at">const</span> <span class="kw">noexcept</span>
    {
        <span class="cf">return</span> <span class="bu">std::</span>string_view( ptr, size ) ;
    }
}

<span class="co">// これひとつだけでよい。</span>
<span class="dt">void</span> process_string( <span class="bu">std::</span>string_view s ) ;

<span class="dt">int</span> main()
{
    <span class="co">// OK</span>
    process_string( <span class="st">&quot;hello&quot;</span> ) ;
    <span class="co">// OK</span>
    process_string( <span class="st">&quot;hello&quot;</span>, <span class="dv">5</span> ) ;

    <span class="bu">std::</span>string str(<span class="st">&quot;hello&quot;</span>) ;
    process_string( str ) ;
}</code></pre></div>
<h2 id="basic_string_view">basic_string_view</h2>
<p>std::stringがstd::basic_string&lt; CharT, Traits &gt;に対するstd::basic_string<char>であるように、std::string_viewも、その実態はstd::basic_string_viewの特殊化へのtypedef名だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 本体</span>
<span class="kw">template</span>&lt;<span class="kw">class</span> charT, <span class="kw">class</span> traits = char_traits&lt;charT&gt;&gt;
<span class="kw">class</span> basic_string_view ;

<span class="co">// それぞれの文字型のtypedef名</span>
<span class="kw">using</span> string_view = basic_string_view&lt;<span class="dt">char</span>&gt;;
<span class="kw">using</span> u16string_view = basic_string_view&lt;<span class="dt">char16_t</span>&gt;;
<span class="kw">using</span> u32string_view = basic_string_view&lt;<span class="dt">char32_t</span>&gt;;
<span class="kw">using</span> wstring_view = basic_string_view&lt;<span class="dt">wchar_t</span>&gt;;</code></pre></div>
<p>なので、通常はbasic_string_viewではなく、string_viewとかu16string_viewなどのtypedef名を使うことになる。本書ではstring_viewだけを解説するが、その他のtypedef名も文字型が違うだけで同じだ。</p>
<h2 id="文字列の所有非所有">文字列の所有、非所有</h2>
<p>string_viewは文字列を所有しない。所有というのは、文字列を表現するストレージの確保と破棄に責任を持つということだ。所有しないことの意味を説明するために、まず文字列を所有するライブラリについて説明する。</p>
<p>std::stringは文字列を所有する。std::string風のクラスの実装は、例えば以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> string
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> * ptr ;

<span class="kw">public</span> :
    <span class="co">// 文字列を表現するストレージの動的確保</span>
    string ( <span class="dt">char</span> <span class="at">const</span> * str )
    {
        size = <span class="bu">std::</span>strlen( str ) ;
        ptr = <span class="kw">new</span> <span class="dt">char</span>[size<span class="dv">+1</span>] ;
        <span class="bu">std::</span>strcpy( ptr, str ) ;
    }

    <span class="co">// コピー</span>
    <span class="co">// 別のストレージを動的確保</span>
    string ( string <span class="at">const</span> &amp; r )
        : size( r.size ), ptr ( <span class="kw">new</span> <span class="dt">char</span>[size<span class="dv">+1</span>] )
    {
        <span class="bu">std::</span>strcpy( ptr, r.ptr ) ;
    }

    <span class="co">// ムーブ</span>
    <span class="co">// 所有権の移動</span>
    string ( string &amp;&amp; r )
        : size( r.size ), ptr( r.ptr )
    {
        r.size = <span class="dv">0</span> ;
        r.ptr = <span class="kw">nullptr</span> ;
    }

    <span class="co">// 破棄</span>
    <span class="co">// 動的確保したストレージを解放</span>
    ~string()
    {
        <span class="kw">delete</span>[] ptr ;
    }
    
} ;</code></pre></div>
<p>std::stringは文字列を表現するストレージを動的に確保し、所有する。コピーは別のストレージを確保する。ムーブするときはストレージの所有権を移す。デストラクターは所有しているストレージを破棄する。</p>
<p>std::string_viewは文字列を所有しない。std::string_view風のクラスの実装は、例えば以下のようになる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> string_view
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> <span class="at">const</span> * ptr ;

<span class="kw">public</span> :

    <span class="co">// 所有しない</span>
    <span class="co">// strの参照先の寿命は呼び出し側が責任を持つ</span>
    string_view( <span class="dt">char</span> <span class="at">const</span> * str ) <span class="kw">noexcept</span>
        : size( <span class="bu">std::</span>strlen(str) ), ptr( str )
    { }

    <span class="co">// コピー</span>
    <span class="co">// メンバーごとのコピーだけでよいのでdefault化するだけでよい</span>
    string_view( string_view <span class="at">const</span> &amp; r ) <span class="kw">noexcept</span> = <span class="cf">default</span> ;

    <span class="co">// ムーブはコピーと同じ</span>
    <span class="co">// 所有しないので所有権の移動もない</span>

    <span class="co">// 破棄</span>
    <span class="co">// 何も開放するストレージはない</span>
    <span class="co">// デストラクターもトリビアルでよい</span>
} ;</code></pre></div>
<p>string_viewに渡した連続した文字型の配列へのポインターの寿命は、渡した側が責任を持つ。つまり、以下のようなコードは間違っている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>string_view get_string()
{
    <span class="dt">char</span> str[] = <span class="st">&quot;hello&quot;</span> ;

    <span class="co">// エラー</span>
    <span class="co">// strの寿命は関数の呼び出し元に戻った時点で尽きている</span>
    <span class="cf">return</span> str ;
}</code></pre></div>
<h2 id="string_viewの構築">string_viewの構築</h2>
<p>string_viewの構築には4種類ある。</p>
<ul>
<li>デフォルト構築</li>
<li>null終端された文字型の配列へのポインター</li>
<li>文字方の配列へのポインターと文字数</li>
<li>文字列クラスからの変換関数</li>
</ul>
<h3 id="デフォルト構築">デフォルト構築</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> basic_string_view() <span class="kw">noexcept</span>;</code></pre></div>
<p>string_viewのデフォルト構築は、空のstring_viewを作る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 空のstring_view</span>
    <span class="bu">std::</span>string_view s ;
}</code></pre></div>
<h3 id="null終端された文字型の配列へのポインター">null終端された文字型の配列へのポインター</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> basic_string_view(<span class="at">const</span> charT* str);</code></pre></div>
<p>このstring_viewのコンストラクターは、null終端された文字型へのポインターを受け取る。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string_view s( <span class="st">&quot;hello&quot;</span> ) ;
}</code></pre></div>
<h3 id="文字型へのポインターと文字数">文字型へのポインターと文字数</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> basic_string_view(<span class="at">const</span> charT* str, <span class="dt">size_type</span> len);</code></pre></div>
<p>このstring_viewのコンストラクターは、文字型の配列へのポインターと文字数を受け取る。ポインターはnull終端されていなくてもよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">char</span> str[] = {<span class="st">&#39;h&#39;</span>, <span class="st">&#39;e&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;l&#39;</span>, <span class="st">&#39;o&#39;</span>} ;

    <span class="bu">std::</span>string_view s( str, <span class="dv">5</span> ) ;
}</code></pre></div>
<h2 id="文字列クラスからの変換関数">文字列クラスからの変換関数</h2>
<p>他の文字列クラスからstring_viewを作るには、変換関数を使う。string_viewのコンストラクターは使わない。</p>
<p>std::stringはstring_viewへの変換関数をサポートしている。独自の文字列クラスをstring_viewに対応させるにも変換関数を使う。例えば以下のように実装する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> string
{
    <span class="bu">std::</span>size_t size ;
    <span class="dt">char</span> * ptr ;
<span class="kw">public</span> :
    <span class="kw">operator</span> <span class="bu">std::</span>string_view() <span class="at">const</span> <span class="kw">noexcept</span>
    {
        <span class="cf">return</span> <span class="bu">std::</span>string_view( ptr, size ) ;
    }
} ;</code></pre></div>
<p>これにより、std::stringからstring_viewへの変換が可能になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;
    <span class="bu">std::</span>string_view sv = s ;
}</code></pre></div>
<p>コレと同じ方法を使えば、独自の文字列クラスもstring_viewに対応させることができる。</p>
<p>std::stringはstring_viewを受け取るコンストラクターを持っているので、string_viewからstringへの変換もできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string_view sv = <span class="st">&quot;hello&quot;</span> ;

    <span class="co">// コピーされる</span>
    <span class="bu">std::</span>string s = sv ;
}</code></pre></div>
<h2 id="string_viewの操作">string_viewの操作</h2>
<p>string_viewは既存の標準ライブラリのstringとほぼ同じ操作性を提供している。例えばイテレーターを取ることができるし、operator []で要素にアクセスできるし、size()で要素数が返るし、find()で検索もできる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> T &gt;
<span class="dt">void</span> f( T  t )
{
    <span class="cf">for</span> ( <span class="kw">auto</span> c : t )
    {
        <span class="bu">std::</span>cout &lt;&lt; c ;
    }

    <span class="cf">if</span> ( t.size() &gt; <span class="dv">3</span> )
    {
        <span class="kw">auto</span> c = t[<span class="dv">3</span>] ;
    }

    <span class="kw">auto</span> pos = t.find( <span class="st">&quot;fox&quot;</span> ) ;
}

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s(<span class="st">&quot;quick brown fox jumps over the lazy dog.&quot;</span>) ;

    f( s ) ;

    <span class="bu">std::</span>string_view sv = s ;

    f( sv ) ;
}</code></pre></div>
<p>string_viewは文字列を所有しないので、文字列を書き換える方法を提供していない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;

    s[<span class="dv">0</span>] = <span class="st">&#39;H&#39;</span> ;
    s += <span class="st">&quot;,world&quot;</span> ;

    <span class="bu">std::</span>string_view sv = s ;

    <span class="co">// エラー</span>
    <span class="co">// string_viewは書き換えられない</span>
    sv[<span class="dv">0</span>] = <span class="st">&#39;h&#39;</span> ;
    s += <span class="st">&quot;.</span><span class="sc">\n</span><span class="st">&quot;</span> ;
}</code></pre></div>
<p>string_viewは文字列を所有せず、ただ参照しているだけだからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;
    <span class="bu">std::</span>string_view sv = s ;

    <span class="co">// &quot;hello&quot;</span>
    <span class="bu">std::</span>cout &lt;&lt; sv ;

    s = <span class="st">&quot;world&quot;</span> ;

    <span class="co">// &quot;world&quot;</span>
    <span class="co">// string_viewは参照しているだけ</span>
    <span class="bu">std::</span>cout &lt;&lt; sv ;
}</code></pre></div>
<p>string_vieはstringとほぼ互換性のあるメンバーを持っているが、一部の文字列を変更するメンバーは削除されている。</p>
<h3 id="remove_prefixremove_suffix-先頭末尾の要素の削除">remove_prefix/remove_suffix : 先頭、末尾の要素の削除</h3>
<p>string_viewは先頭と末尾からn個の要素を削除するメンバー関数を提供している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">constexpr</span> <span class="dt">void</span> remove_prefix(<span class="dt">size_type</span> n);
<span class="kw">constexpr</span> <span class="dt">void</span> remove_suffix(<span class="dt">size_type</span> n);</code></pre></div>
<p>string_viewにとって、先頭と末尾からn個の要素を削除するのは、ポインターをn個ずらすだけなので、これは文字列を所有しないstring_viewでも行える操作だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>string s = <span class="st">&quot;hello&quot;</span> ;

    <span class="bu">std::</span>string_view s1 = s ;

    <span class="co">// &quot;lo&quot;</span>
    s1.remove_prefix(<span class="dv">3</span>) ;

    <span class="bu">std::</span>string_view s2 = s ;

    <span class="co">// &quot;he&quot;</span>
    s2.remove_suffix(<span class="dv">3</span>) ;
}</code></pre></div>
<p>このメンバー関数は既存のstd::stringにも追加されている。</p>
<h2 id="ユーザー定義リテラル">ユーザー定義リテラル</h2>
<p>std::stringとstd::string_viewにはユーザー定義リテラルが追加されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">string operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">char</span>* str, <span class="dt">size_t</span> len);
u16string operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">char16_t</span>* str, <span class="dt">size_t</span> len);
u32string operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">char32_t</span>* str, <span class="dt">size_t</span> len);
wstring operator<span class="st">&quot;&quot;</span>s(<span class="at">const</span> <span class="dt">wchar_t</span>* str, <span class="dt">size_t</span> len);

<span class="kw">constexpr</span> string_view operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">char</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;
<span class="kw">constexpr</span> u16string_view operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">char16_t</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;
<span class="kw">constexpr</span> u32string_view operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">char32_t</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;
<span class="kw">constexpr</span> wstring_view operator<span class="st">&quot;&quot;</span>sv(<span class="at">const</span> <span class="dt">wchar_t</span>* str, <span class="dt">size_t</span> len) <span class="kw">noexcept</span>;</code></pre></div>
<p>以下のように使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">using</span> <span class="kw">namespace</span> <span class="bu">std::</span>literals ;

    <span class="co">// std::string</span>
    <span class="kw">auto</span> s = <span class="st">&quot;hello&quot;</span>s ;

    <span class="co">// std::string_view</span>
    <span class="kw">auto</span> sv = <span class="st">&quot;hello&quot;</span>sv ;
}</code></pre></div>
<h1 id="メモリーリソース-動的ストレージ確保ライブラリ">メモリーリソース : 動的ストレージ確保ライブラリ</h1>
<p>ヘッダーファイル&lt;memory_resource&gt;で定義されているメモリーリソースは、動的ストレージを確保するためのC++17で追加されたライブラリだ。その特徴は以下の通り。</p>
<ul>
<li>アロケーターに変わる新しいインターフェースとしてのメモリーリソース</li>
<li>ポリモーフィックな振る舞いを可能にするアロケーター</li>
<li>標準で提供される様々な特性を持ったメモリーリソースの実装</li>
</ul>
<h2 id="メモリーリソース">メモリーリソース</h2>
<p>メモリーリソースはアロケーターに変わる新しいメモリ確保と解放のためのインターフェースとしての抽象クラスだ。コンパイル時に挙動を変える静的ポリモーフィズム設計のアロケーターと違い、メモリーリソースは実行時に挙動を変える動的ポリモーフィズム設計となっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( memory_resource * mem )
{
    <span class="co">// 10バイトのストレージを確保</span>
    <span class="kw">auto</span> ptr = mem-&gt;allocate( <span class="dv">10</span> ) ;
    <span class="co">// 確保したストレージを解放</span>
    mem-&gt;deallocate( ptr ) ;
}</code></pre></div>
<p>クラスstd::pmr::memory_resourceの宣言は以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">class</span> memory_resource {
<span class="kw">public</span>:
    <span class="kw">virtual</span> ~ memory_resource();
    <span class="dt">void</span>* allocate(<span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment = max_align);
    <span class="dt">void</span> deallocate(<span class="dt">void</span>* p, <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment = max_align);
    <span class="dt">bool</span> is_equal(<span class="at">const</span> memory_resource&amp; other) <span class="at">const</span> <span class="kw">noexcept</span>;

<span class="kw">private</span>:
    <span class="kw">virtual</span> <span class="dt">void</span>* do_allocate(<span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">void</span> do_deallocate(<span class="dt">void</span>* p, <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">bool</span> do_is_equal(<span class="at">const</span> memory_resource&amp; other) <span class="at">const</span> <span class="kw">noexcept</span> = <span class="dv">0</span>;
};

}</code></pre></div>
<p>クラスmemory_resourceはstd::pmr名前空間スコープのなかにある。</p>
<h3 id="メモリーリソースの使い方">メモリーリソースの使い方</h3>
<p>memory_resourceを使うのは簡単だ。memory_resourceのオブジェクトを確保したら、メンバー関数allocate( bytes, alignment )でストレージを確保する。メンバー関数deallocate( p, bytes, alignment )でストレージを解放する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * mem )
{
    <span class="co">// 100バイトのストレージを確保</span>
    <span class="dt">void</span> * ptr = mem-&gt;allocate( <span class="dv">100</span> ) ;
    <span class="co">// ストレージを解放</span>
    mem-&gt;deallocate( ptr, <span class="dv">100</span> ) ;
}</code></pre></div>
<p>二つのmemory_resourceのオブジェクトa, bがあるとき、一方のオブジェクトで確保したストレージをもう一方のオブジェクトで解放できるとき、a.is_equal( b )はtrueを返す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * a, <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resouce * b )
{
    <span class="dt">void</span> * ptr = a-&gt;allocate( <span class="dv">1</span> ) ;

    <span class="co">// aで確保したストレージはbで解放できるか？</span>
    <span class="cf">if</span> ( a-&gt;is_equal( *b ) )
    {<span class="co">// できる</span>
        b-&gt;deallocate( ptr, <span class="dv">1</span> ) ;
    }
    <span class="cf">else</span>
    {<span class="co">// できない</span>
        a-&gt;deallocate( ptr, <span class="dv">1</span> ) ;
    }
}</code></pre></div>
<p>is_equalを呼び出すoperator ==とoperator !=も提供されている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f( <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * a, <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource * b )
{
    <span class="dt">bool</span> b1 = ( *a == *b ) ;
    <span class="dt">bool</span> b2 = ( *a != *b ) ;
}</code></pre></div>
<h3 id="メモリーリソースの作り方">メモリーリソースの作り方</h3>
<p>独自のメモリーアロケーターをmemory_resouceのインターフェースに合わせて作るには、memory_resourceから派生した上で、do_allocate, do_deallocate, do_is_equalの3つのprivate純粋virtualメンバー関数をオーバーライドする。必要に応じてデストラクターもオーバーライドする。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> memory_resource {
<span class="co">// 非公開</span>
<span class="at">static</span> <span class="kw">constexpr</span> <span class="dt">size_t</span> max_align = <span class="kw">alignof</span>(<span class="dt">max_align_t</span>);

<span class="kw">public</span>:
    <span class="kw">virtual</span> ~ memory_resource();

<span class="kw">private</span>:
    <span class="kw">virtual</span> <span class="dt">void</span>* do_allocate(<span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">void</span> do_deallocate(<span class="dt">void</span>* p, <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment) = <span class="dv">0</span>;
    <span class="kw">virtual</span> <span class="dt">bool</span> do_is_equal(<span class="at">const</span> memory_resource&amp; other) <span class="at">const</span> <span class="kw">noexcept</span> = <span class="dv">0</span>;
};</code></pre></div>
<p>do_allocate(bytes, alignment)は少なくともalignmentバイトでアライメントされたbytesバイトのストレージへのポインターを返す。ストレージが確保できなかった場合は、適切な例外をthrowする。</p>
<p>do_deallocate(p, bytes, alignment)は事前に同じ*thisから呼び出されたallocate( bytes, alignment )で返されたポインターpを解放する。すでに解放されたポインターpを渡してはならない。例外は投げない。</p>
<p>do_is_equal(other)は、*thisとotherが互いに一方で確保したストレージをもう一方で解放できる場合にtrueを返す。</p>
<p>たとえば、malloc/freeを使ったmemory_resouceの実装は以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="co">// malloc/freeを使ったメモリーリソース</span>
<span class="kw">class</span> malloc_resource : <span class="kw">public</span> <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource
{
<span class="kw">public</span> :
    <span class="co">//</span>
    ~malloc_resource() { }
<span class="kw">private</span> :
    <span class="co">// ストレージの確保</span>
    <span class="co">// 失敗した場合std::bad_allocをthrowする</span>
    <span class="kw">virtual</span> <span class="dt">void</span> * do_allocate( <span class="bu">std::</span>size_t bytes, <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="dt">void</span> * ptr = <span class="bu">std::</span>malloc( bytes ) ;
        <span class="cf">if</span> ( ptr == <span class="kw">nullptr</span> )
        { <span class="cf">throw</span> <span class="bu">std::</span>bad_alloc{} ; }

        <span class="cf">return</span> ptr ;
    }

    <span class="co">// ストレージの解放</span>
    <span class="kw">virtual</span> <span class="dt">void</span> do_deallocate( <span class="dt">void</span> * p, <span class="bu">std::</span>size_t bytes, <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="bu">std::</span>free( p ) ;
    }

    <span class="kw">virtual</span> <span class="dt">bool</span> do_is_equal( <span class="at">const</span> memory_resource &amp; other ) <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span>
    {
        <span class="cf">return</span> <span class="kw">dynamic_cast</span>&lt; <span class="at">const</span> malloc_resource * &gt;( &amp;other ) != <span class="kw">nullptr</span> ;
    }

} ;</code></pre></div>
<p>do_allocateはmallocでストレージを確保し、do_deallocateはfreeでストレージを解放する。メモリーリソースで0バイトのストレージを確保しようとしたときの規定はないので、mallocの挙動に任せる。mallocは0バイトのメモリを確保しようとしたとき、C11では規定がない。posixではnullポインターを返すか、freeで解放可能な何らかのアドレスを返すものとしている。</p>
<p>do_is_equalは、malloc_resourceでさえあればどのオブジェクトから確保されたストレージであっても解放できるので、*thisがmalloc_resourceであるかどうかをdynamic_castで確認している。</p>
<h2 id="polymorphic_allocator-動的ポリモーフィズムを実現するアロケーター">polymorphic_allocator : 動的ポリモーフィズムを実現するアロケーター</h2>
<p>std::pmr::polymorphic_allocatorはメモリーリソースを動的ポリモーフィズムとして振る舞うアロケーターにするためのライブラリだ。</p>
<p>従来のアロケーターは、静的ポリモーフィズムを実現するために設計されていた。例えば独自のcustom_int_allocator型を使いたい場合は以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>vector&lt; <span class="dt">int</span>, custom_int_allocator &gt; v ;</code></pre></div>
<p>コンパイル時に使うべきアロケーターが決定できる場合はこれでいいのだが、実行時にアロケーターを選択したい場合、アロケーターをテンプレート引数に取る設計は問題になる。</p>
<p>そのため、C++17ではメモリーリソースをコンストラクター引数にとり、メモリーリソースからストレージを確保する実行時ポリモーフィックの振る舞いをするstd::pmr::polymorphic_allocatorが追加された。</p>
<p>例えば、標準入力からtrueかfalseが入力されたかによって、システムのデフォルトのメモリーリソースと、monotonic_buffer_resourceを実行時に切り替えるには、以下のようにかける。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">bool</span> b;

    <span class="bu">std::</span>cin &gt;&gt; b ;

    <span class="bu">std::</span>pmr<span class="bu">::</span>mempry_resource * mem ;
    <span class="bu">std::</span>unique_ptr&lt; memory_resource &gt; mono ;

    <span class="cf">if</span> ( b )
    { <span class="co">// デフォルトのメモリーリソースを使う</span>
        mem = <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ;
    }
    <span class="cf">else</span>
    { <span class="co">// モノトニックバッファーを使う</span>
        mono = <span class="bu">std::</span>make_unique&lt; <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource &gt;( <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ) ;
        mem = mono.get() ;
    }

    <span class="bu">std::</span>vector&lt; <span class="dt">int</span>, <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt; &gt; v( <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt;( mem ) ) ;
}</code></pre></div>
<p>std::pmr::polymorphic_allocatorは以下のように宣言されている</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">template</span> &lt;<span class="kw">class</span> T&gt;
<span class="kw">class</span> polymorphic_allocator ;

}</code></pre></div>
<p>テンプレート実引数にはstd::allocator&lt;T&gt;と同じく、確保する型を与える。</p>
<h3 id="コンストラクター">コンストラクター</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">polymorphic_allocator() <span class="kw">noexcept</span>;
polymorphic_allocator(memory_resource* r);</code></pre></div>
<p>std::pmr::polymorphic_allocatorのデフォルトコンストラクターは、メモリーリソースをstd::pmr::get_default_resource()で取得する。</p>
<p>memory_resource *を引数に取るコンストラクターは、渡されたメモリーリソースをストレージ確保に使う。polymorphic_allocatorの生存期間中、メモリーリソースへのポインターは妥当なものでなければならない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// p1( std::pmr::get_default_resource () ) と同じ</span>
    <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt; p1 ;

    <span class="bu">std::</span>pmr<span class="bu">::</span>polymorphic_allocator&lt;<span class="dt">int</span>&gt; p2( <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ) ;
}</code></pre></div>
<p>後は通常のあロケーターと同じように振る舞う。</p>
<h2 id="プログラム全体で使われるメモリーリソースの取得">プログラム全体で使われるメモリーリソースの取得</h2>
<p>C++17では、プログラム全体で使われるメモリーリソースへのポインターを取得することができる。</p>
<h3 id="new_delete_resource">new_delete_resource()</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* new_delete_resource() <span class="kw">noexcept</span> ;</code></pre></div>
<p>関数new_delete_resourceはメモリーリソースへのポインターを返す。参照されるメモリーリソースは、ストレージの確保に::operator newを使い、ストレージの解放に::operator deleteを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> mem = <span class="bu">std::</span>pmr<span class="bu">::</span>new_delete_resource() ;
}</code></pre></div>
<h3 id="null_memory_resource">null_memory_resource()</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* null_memory_resource() <span class="kw">noexcept</span> ;</code></pre></div>
<p>関数null_memory_resourceはメモリーリソースへのポインターを返す。参照されるメモリーリソースのallocateは必ず失敗し、std::bad_allocをthrowする。deallocateは何もしない。</p>
<p>このメモリーリソースは、ストレージの確保に失敗した場合のコードをテストする目的で使える。</p>
<h3 id="デフォルトリソース">デフォルトリソース</h3>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* set_default_resource(memory_resource* r) <span class="kw">noexcept</span> ;
memory_resource* get_default_resource() <span class="kw">noexcept</span> ;</code></pre></div>
<p>デフォルト・メモリーリソース・ポインターとは、メモリーリソースを明示的に指定することができない場合に、システムがデフォルトで利用するメモリーリソースへのポインターのことだ。初期値はnew_delete_resource()の戻り値となっている。</p>
<p>現在のデフォルト・メモリーリソース・ポインターと取得するためには、関数get_default_resourceを使う。デフォルト・メモリーリソース・ポインターを独自のメモリーリソースに差し替えるには、関数set_default_resourceを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// 現在のデフォルトのメモリーリソースへのポインター</span>
    <span class="kw">auto</span> init_mem = <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ;

    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource pool_mem ;

    <span class="co">// デフォルトのメモリーリソースを変更する</span>
    <span class="bu">std::</span>pmr<span class="bu">::</span>set_default_resource( &amp;pool_mem ) ;

    <span class="kw">auto</span> current_mem = <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ;

    <span class="co">// true</span>
    <span class="dt">bool</span> b = current_mem == pool_mem ;
}</code></pre></div>
<h2 id="標準ライブラリのメモリーリソース">標準ライブラリのメモリーリソース</h2>
<p>標準ライブラリはメモリーリソースの実装として、プールリソースとモノトニックリソースを提供している。このメモリーリソースの詳細は後に解説するが、ここではそのための事前知識として、汎用的なメモリーアロケーター一般の解説をする。</p>
<p>プログラマーはメモリーを気軽に確保している。例えば47バイトとか151バイトのような中途半端なサイズのメモリーを以下のように気軽に確保している。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="kw">auto</span> mem = <span class="bu">std::</span>get_default_resource() ;

    <span class="kw">auto</span> p1 = mem-&gt;allocate( <span class="dv">47</span> ) ;
    <span class="kw">auto</span> p2 = mem-&gt;allocate( <span class="dv">151</span> ) ;

    mem-&gt;deallocate( p1 ) ;
    mem-&gt;deallocate( p2 ) ;
}</code></pre></div>
<p>しかし、残念ながら現実のハードウェアやOSのメモリ管理は、このように柔軟にはできていない。例えば、あるアーキテクチャーとOSでは、メモリはページサイズと呼ばれる単位でしか確保できない。そして最小のページサイズですら4KBであったりする。もしシステムの低級なメモリ管理を使って上のコードを実装しようとすると、47バイト程度のメモリを使うのに3KB超の無駄が生じることになる。</p>
<p>他にもアライメントの問題がある。アーキテクチャによってはメモリアドレスが適切なアライメントに配置されていないとメモリアクセスができないか、著しくパフォーマンスが落ちることがある。</p>
<p>mallocやoperator newなどのメモリーアロケーターは、低級なメモリ管理を隠匿し、小さなサイズのメモリ確保を効率的に行うための実装をしている。</p>
<p>一般的には、大きな連続したアドレス空間のメモリを確保し、その中に管理用のデータ構造を作り、メモリを必要なサイズに切り出す。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="co">// ストレージを分割して管理するためのリンクリストデータ構造</span>
<span class="kw">struct</span> <span class="kw">alignas</span>(<span class="bu">std::</span>max_align_t) chunk
{
    chunk * next ;
    chunk * prev ;
    <span class="bu">std::</span>size_t size ;
} ;

<span class="kw">class</span> memory_allocator : <span class="kw">public</span> <span class="bu">std::</span>pmr<span class="bu">::</span>memory_resource
{
    chunk * ptr ; <span class="co">// ストレージの先頭へのポインター</span>
    <span class="bu">std::</span>size_t size ; <span class="co">// ストレージのサイズ</span>
    <span class="bu">std::</span>mutex m ; <span class="co">// 同期用</span>

    
<span class="kw">public</span> :

    memory_allocator()
    {
        <span class="co">// 大きな連続したストレージを確保</span>
    }

    <span class="kw">virtual</span> <span class="dt">void</span> * do_allocate( <span class="bu">std::</span>size_t bytes, <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="bu">std::</span>scoped_lock lock( m ) ; 
        <span class="co">// リンクリストをたどり、十分な大きさの未使用領域を探し、リンクリスト構造体を構築して返す</span>
        <span class="co">// アライメント要求に注意</span>
    }

    <span class="kw">virtual</span> <span class="dt">void</span> * do_allocate( <span class="bu">std::</span>size_t bytes, <span class="bu">std::</span>size_t alignment ) <span class="kw">override</span>
    {
        <span class="bu">std::</span>scoped_lock lock( m ) ;
        <span class="co">// リンクリストから該当する部分を削除</span>
    }

    <span class="kw">virtual</span> <span class="dt">bool</span> do_is_equal( <span class="at">const</span> memory_resource &amp; other ) <span class="at">const</span> <span class="kw">noexcept</span> <span class="kw">override</span>
    { 
    <span class="co">// *thisとotherで相互にストレージを解放できるかどうか返す</span>
    }
} ;</code></pre></div>
<h2 id="プールリソース">プールリソース</h2>
<p>プールリソースはC++17の標準ライブラリが提供しているメモリーリソースの実装だ。synchronized_pool_resourcceとunsynchronized_pool_resourceの二つがある。</p>
<h3 id="アルゴリズム">アルゴリズム</h3>
<p>プールリソースは以下のような特徴を持つ。</p>
<ul>
<li>プールリソースのオブジェクトが破棄されるとき、そのオブジェクトからallocateで確保したストレージは、明示的にdeallocateを呼ばずとも解放される。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> f()
{
    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource mem ;
    mem.allocate( <span class="dv">10</span> ) ;

    <span class="co">// 確保したストレージは破棄される</span>
}</code></pre></div>
<ul>
<li>プールリソースの構築時に、上流メモリーリソースを与えることができる。プールリソースは上流メモリーリソースからチャンクのためのストレージを確保する。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="co">// get_default_resource()が使われる</span>
    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource m1 ;

    <span class="co">// 独自の上流メモリーリソースを指定</span>
    custom_memory_resource mem ;
    <span class="bu">std::</span>pmr<span class="bu">::</span>synchronized_pool_resource m2( &amp;mem ) ;
    
}</code></pre></div>
<ul>
<li><p>プールリソースはストレージを確保する上流メモリーリソースから、プールと呼ばれる複数のストレージを確保する。ブールは複数のチャンクを保持している。チャンクは複数の同一サイズのブロックを保持している。プールリソースに対するdo_allocate(size, alignment)は、少なくともsizeバイトのブロックサイズのプールのいずれかのチャンクのブロックが割り当てられる。</p>
<p>もし、最大のブロックサイズを超えるサイズのストレージを確保しようとした場合、上流メモリーリソースから確保される。</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="co">// チャンクの実装</span>
<span class="kw">template</span> &lt; <span class="dt">size_t</span> block_size &gt;
<span class="kw">class</span> chunk
{
    blocks&lt;block_size&gt; b ;
}

<span class="co">// プールの実装</span>
<span class="kw">template</span> &lt; <span class="dt">size_t</span> block_size &gt;
<span class="kw">class</span> pool : <span class="kw">public</span> memory_resource
{
    chunks&lt;block_size&gt; c ;
} ;

<span class="kw">class</span> pool_resource : <span class="kw">public</span> memory_resource
{
    <span class="co">// それぞれのブロックサイズのプール</span>
    pool&lt;<span class="dv">8</span>&gt; pool_8bytes ;
    pool&lt;<span class="dv">16</span>&gt; pool_16bytes ;
    pool&lt;<span class="dv">32</span>&gt; pool_32bytes ;

    <span class="co">// 上流メモリーリソース</span>
    memory_resource * mem ;


    <span class="kw">virtual</span> <span class="dt">void</span> * do_allocate( <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="co">// 対応するブロックサイズのプールにディスパッチ</span>
        <span class="cf">if</span> ( bytes &lt;= <span class="dv">8</span> )
            <span class="cf">return</span> pool_8bytes.allocate( bytes, alignment ) ;
        <span class="cf">else</span> <span class="cf">if</span> ( bytes &lt;= <span class="dv">16</span> )
            <span class="cf">return</span> pool_16bytes.allocate( bytes, alignment ) ;
        <span class="cf">else</span> <span class="cf">if</span> ( bytes &lt; <span class="dv">32</span> )
            <span class="cf">return</span> pool_32bytes.allocate( bytes, alignment ) ;
        <span class="cf">else</span>
        <span class="co">// 最大ブロックサイズを超えたので上流メモリーリソースにディスパッチ</span>
            <span class="cf">return</span> mem-&gt;allocate( bytes, alignment ) ;
    }
} ;

}</code></pre></div>
<ul>
<li><p>プールリソースは構築時にpool_optionsを渡すことにより、最大ブロックサイズと最大チャンクサイズを設定できる。</p></li>
<li><p>マルチスレッドから呼び出しても安全な同期を取るsynchronized_pool_resourceと、同期をとらないunsynchronized_pool_resourceがある。</p></li>
</ul>
<h3 id="synchronizedunsynchronized_pool_resource">synchronized/unsynchronized_pool_resource</h3>
<p>プールリソースには、synchronized_pool_resourceとunsynchronized_pool_resourceがある。どちらもクラス名以外は同じように使える。ただし、synchronized_pool_resourceは複数のスレッドから同時に実行しても使えるように内部で同期が取られているのに対し、unsynchronized_pool_resourceは同期を行わない。unsyncrhonized_pool_resourceは複数のスレッドから同時に呼び出すことはできない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">class</span> synchronized_pool_resource : <span class="kw">public</span> memory_resource
{
    <span class="bu">std::</span>mutex m ;

    <span class="kw">virtual</span> <span class="dt">void</span> * do_allocate( <span class="dt">size_t</span> size, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="co">// 同期する</span>
        <span class="bu">std::</span>scoped_lock l(m) ;
        <span class="cf">return</span> do_allocate_impl( size, alignment ) ;
    }
} ;

<span class="kw">class</span> unsynchronized_pool_resource : <span class="kw">public</span> memory_resource
{
    <span class="kw">virtual</span> <span class="dt">void</span> * do_allocate( <span class="dt">size_t</span> size, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="co">// 同期しない</span>
        <span class="cf">return</span> do_allocate_impl( size, alignment ) ;
    }
} ;

}</code></pre></div>
<h3 id="pool_options">pool_options</h3>
<p>pool_optionsはプールリソースの挙動を指定するためのクラスで、以下のように定義されてる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">struct</span> pool_options {
    <span class="dt">size_t</span> max_blocks_per_chunk = <span class="dv">0</span>;
    <span class="dt">size_t</span> largest_required_pool_block = <span class="dv">0</span>;
};

}</code></pre></div>
<p>このクラスのオブジェクトをプールリソースのコンストラクターに与えることで、プールリソースの挙動を指定できる。ただし、pool_optionsによる指定はあくまでも目安で、実装には従う義務はない。</p>
<p>max_blocks_per_chunkは、上流メモリーリソースからプールのチャンクを補充する際に一度に確保する最大のブロック数だ。この値がゼロか、実装の上限より大きい場合、実装の上限が使われる。実装は指定よりも小さい値を使うことができるし、またプールごとに別の値を使うこともできる。</p>
<p>largest_required_pool_blockはプール機構によって確保される最大のストレージのサイズだ。この値より大きなサイズのストレージを確保しようとすると、上流メモリーストレージから直接確保される。この値がゼロか、実装の上限よりも大きい場合、実装の上限が使われる。実装は指定よりも大きい値を使うこともできる。</p>
<h3 id="プールリソースのコンストラクター">プールリソースのコンストラクター</h3>
<p>プールリソースの根本的なコンストラクターは以下の通り。synchronizedとunsynchronizedどちらも同じだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">pool_resource(<span class="at">const</span> pool_options&amp; opts, memory_resource* upstream);

pool_resource()
: pool_resource(pool_options(), get_default_resource()) {}
<span class="kw">explicit</span> pool_resource(memory_resource* upstream)
: pool_resource(pool_options(), upstream) {}
<span class="kw">explicit</span> pool_resource(<span class="at">const</span> pool_options&amp; opts)
: pool_resource(opts, get_default_resource()) {}</code></pre></div>
<p>pool_optionsとmemory_resource *を指定する。指定しない場合はデフォルト値が使われる。</p>
<h3 id="プールリソースのメンバー関数">プールリソースのメンバー関数</h3>
<h4 id="release">release()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> release();</code></pre></div>
<p>確保したストレージ全てを解放する。たとえ明示的にdeallocateを呼び出されていないストレージも解放する。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    synchronized_pool_resource mem ;
    <span class="dt">void</span> * ptr = mem.allocate( <span class="dv">10</span> ) ;

    <span class="co">// ptrは解放される</span>
    mem.release() ;

}</code></pre></div>
<h4 id="upstream_resource">upstream_resource()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* upstream_resource() <span class="at">const</span>;</code></pre></div>
<p>構築時に渡した上流メモリーリソースへのポインターを返す。</p>
<h4 id="options">options()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">pool_options options() <span class="at">const</span>;</code></pre></div>
<p>構築時に渡したpool_optionsオブジェクトと同じ値を返す。</p>
<h2 id="モノトニックバッファーリソース">モノトニックバッファーリソース</h2>
<p>モノトニックバッファーリソースはC++17で標準ライブラリに追加されたメモリーリソースの実装だ。クラス名はmonotonic_buffer_resource。</p>
<p>モノトニックバッファーリソースは高速にメモリーを確保し、一気に解放するという用途に特化した特殊な設計をしている。モノトニックバッファーリソースはメモリー解放をせず、メモリー使用量がモノトニックに増え続けるので、この名前がついている。</p>
<p>例えばゲームで1フレームを描画する際に大量に小さなオブジェクトのためのストレージを確保し、その後確保したストレージをすべて解放したい場合を考える。通常のメモリーアロケーターでは、メモリー片を解放するためにメモリー全体に構築されたデータ構造を辿り、データ構造を書き換えなければならない。この処理は高くつく。すべてのメモリー片を一斉に解放してよいのであれば、データ構造をいちいち辿ったり書き換えたりする必要はない。メモリーの管理は、単にポインターだけでよい。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">namespace</span> <span class="bu">std::</span>pmr {

<span class="kw">class</span> monotonic_buffer_resource : <span class="kw">public</span> memory_resource
{
    <span class="co">// 連続した長大なストレージの先頭へのポインター</span>
    <span class="dt">void</span> * ptr ;
    <span class="co">// 現在の未使用ストレージの先頭へのポインター</span>
    <span class="bu">std::</span>byte * current ;

    <span class="kw">virtual</span> <span class="dt">void</span> * do_allocate( <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment ) <span class="kw">override</span>
    {
        <span class="dt">void</span> * result = <span class="kw">static_cast</span>&lt;<span class="dt">void</span> *&gt;(current) ;
        current += bytes ; <span class="co">// 必要であればアライメント調整</span>
        <span class="cf">return</span> result ;
    }

    <span class="kw">virtual</span> <span class="dt">void</span> do_deallocate( <span class="dt">void</span> * ptr, <span class="dt">size_t</span> bytes, <span class="dt">size_t</span> alignment ) <span class="kw">override</span> 
    {
        <span class="co">// 何もしない</span>
    }

<span class="kw">public</span> :
    ~monotonic_buffer_resource()
    {
        <span class="co">// ptrの解放</span>
    }
} ;

}</code></pre></div>
<p>このように、基本的な実装としては、do_allocateはポインターを加算して管理するだけだ。なぜならば解放処理がいらないため、個々のストレージ片を管理するためのデータ構造を構築する必要がない。do_deallocateはなにもしない。デストラクターはストレージ全体を解放する。</p>
<h3 id="アルゴリズム-1">アルゴリズム</h3>
<p>モノトニックバッファーリソースは以下のような特徴を持つ。</p>
<ul>
<li>deallocate呼び出しは何もしない。メモリー使用量はリソースが破棄されるまでモノトニックに増え続ける。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource mem ;

    <span class="dt">void</span> * ptr = mem.allocate( <span class="dv">10</span> ) ;
    <span class="co">// 何もしない</span>
    <span class="co">// ストレージは解放されない。</span>
    mem.deallocate( ptr ) ;

    <span class="co">// memが破棄される際に確保したストレージはすべて破棄される</span>
}</code></pre></div>
<ul>
<li>メモリー確保に使う初期バッファーを与えることができる。ストレージ確保の際に、初期バッファーに空きがある場合はそこから確保する。空きがない場合は上流メモリーリソースからバッファーを確保して、バッファーから確保する。</li>
</ul>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>byte initial_buffer[<span class="dv">10</span>] ;
    <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource mem( initial_buffer, <span class="dv">10</span>, <span class="bu">std::</span>pmr<span class="bu">::</span>get_default_resource() ) ;

    <span class="co">// 初期バッファーから確保</span>
    mem.allocate( <span class="dv">1</span> ) ;
    <span class="co">// 上流メモリーリソースからストレージを確保して切り出して確保</span>
    mem.allocate( <span class="dv">100</span> ) ;
    <span class="co">// 前回のストレージ確保で空きがあればそこから</span>
    <span class="co">// なければ新たに上流から確保して切り出す。</span>
    mem.allocate( <span class="dv">100</span> ) ;
}</code></pre></div>
<ul>
<li><p>一つのスレッドから使うことを前提に設計されている。allocateとdeallocateは同期しない。</p></li>
<li><p>メモリーリソースが破棄されると確保されたすべてのストレージも解放される。明示的にdeallocateを呼ばなくてもよい。</p></li>
</ul>
<h3 id="コンストラクター-1">コンストラクター</h3>
<p>モノトニックバッファーリソースには以下のコンストラクターがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">
<span class="kw">explicit</span> monotonic_buffer_resource(memory_resource *upstream);
monotonic_buffer_resource(<span class="dt">size_t</span> initial_size, memory_resource *upstream);
monotonic_buffer_resource(<span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size, memory_resource *upstream);


monotonic_buffer_resource()
    : monotonic_buffer_resource(get_default_resource()) {}
<span class="kw">explicit</span> monotonic_buffer_resource(<span class="dt">size_t</span> initial_size)
    : monotonic_buffer_resource(initial_size, get_default_resource()) {}
monotonic_buffer_resource(<span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size)
    : monotonic_buffer_resource(buffer, buffer_size, get_default_resource()) {}</code></pre></div>
<p>初期バッファーを取らないコンストラクターは以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">explicit</span> monotonic_buffer_resource(memory_resource *upstream);
monotonic_buffer_resource(<span class="dt">size_t</span> initial_size, memory_resource *upstream);

monotonic_buffer_resource()
    : monotonic_buffer_resource(get_default_resource()) {}
<span class="kw">explicit</span> monotonic_buffer_resource(<span class="dt">size_t</span> initial_size)
    : monotonic_buffer_resource(initial_size, get_default_resource()) {}</code></pre></div>
<p>initial_sizeは、上流メモリーリソースから最初に確保するバッファーのサイズ(初期サイズ)のヒントとなる。実装はこのサイズか、あるいは実装依存のサイズをバッファーとして確保する。</p>
<p>デフォルトコンストラクターは上流メモリーリソースにstd::pmr_get_default_resource()を与えたのと同じ挙動になる。</p>
<p>size_tひとつだけを取るコンストラクターは、初期サイズだけを与えて後はデフォルトの扱いになる。</p>
<p>初期バッファーをとるコンストラクターは以下の通り。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">monotonic_buffer_resource(<span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size, memory_resource *upstream);

monotonic_buffer_resource(<span class="dt">void</span> *buffer, <span class="dt">size_t</span> buffer_size)
    : monotonic_buffer_resource(buffer, buffer_size, get_default_resource()) {}</code></pre></div>
<p>初期バッファーは先頭アドレスをvoid *型で渡し、そのサイズをsize_t型で渡す。</p>
<h3 id="その他の操作">その他の操作</h3>
<h4 id="release-1">release()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">void</span> release() ;</code></pre></div>
<p>メンバー関数releaseは、上流リソースから確保されたストレージをすべて解放する。明示的にdeallocateを呼び出していないストレージも解放される。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>pmr<span class="bu">::</span>monotonic_buffer_resource mem ;

    mem.allocate( <span class="dv">10</span> ) ;

    <span class="co">// ストレージはすべて解放される</span>
    mem.release() ;

}</code></pre></div>
<h4 id="upstream_resource-1">upstream_resource()</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">memory_resource* upstream_resource() <span class="at">const</span>;</code></pre></div>
<p>メンバー関数uptream_resourceは、構築時に与えられた上流メモリーリソースへのポインターを返す。</p>
<h1 id="並列アルゴリズム">並列アルゴリズム</h1>
<p>並列アルゴリズムはC++17で追加された新しいライブラリだ。このライブラリは既存の&lt;algorithm&gt;に、並列実行版を追加する。</p>
<h2 id="並列実行について">並列実行について</h2>
<p>C++11では、スレッドと同期処理が追加され、複数の実行媒体が同時に実行されるという概念がC++標準規格に入った。</p>
<p>C++17では、既存のアルゴリズムに、並列実行版が追加された。</p>
<p>例えば、all_of(first, last, pred)というアルゴリズムは、[first,last)の区間が空であるか、すべてのイテレーターiに対してpred(*i)がtrueを返すとき、trueを返す。それ以外の場合はfalseを返す。</p>
<p>すべての値が100未満であるかどうかを調べるには、以下のように書く。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="cf">return</span> <span class="bu">std::</span>all_of( <span class="bu">std::</span>begin(input), <span class="bu">std::</span>end(input),
        []( <span class="kw">auto</span> x ) { <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ;
}

<span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; input ;
    <span class="bu">std::</span>copy( <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(<span class="bu">std::</span>cin), <span class="bu">std::</span>istream_iterator&lt;<span class="dt">int</span>&gt;(), <span class="bu">std::</span>back_inserter(input) ) ;

    <span class="dt">bool</span> result = is_all_of_less_than_100( input ) ;

    <span class="bu">std::</span>cout &lt;&lt; <span class="st">&quot;result : &quot;</span> &lt;&lt; result &lt;&lt; <span class="bu">std::</span>endl ;
}</code></pre></div>
<p>本書の執筆時点では、コンピューターはマルチコアが一般的になり、同時に複数のスレッドを実行できるようになった。さっそくこの処理を二つのスレッドで並列化してみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> double_is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="kw">auto</span> first = <span class="bu">std::</span>begin(input) ;
    <span class="kw">auto</span> last = first + (input.size()/<span class="dv">2</span>) ;

    <span class="kw">auto</span> r1 = <span class="bu">std::</span>async( [=]{ <span class="cf">return</span> <span class="bu">std::</span>all_of( first, last, [](<span class="kw">auto</span> x) { <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ; } ) ;

    first = last ;
    last = <span class="bu">std::</span>end(input) ;

    <span class="kw">auto</span> r2 = <span class="bu">std::</span>async( [=]{ <span class="cf">return</span> <span class="bu">std::</span>all_of( first, last, [](<span class="kw">auto</span> x) { <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ; } ) ;

    <span class="cf">return</span> r1.get() &amp;&amp; r2.get() ;
}</code></pre></div>
<p>なるほど、とてもわかりにくいコードだ。</p>
<p>筆者のコンピューターのCPUは二つの物理コア、4つの論理コアを持っているので、4スレッドまで同時に並列実行できる。読者の使っているコンピューターは、より高性能で更に多くのスレッドを同時に実行可能だろう。実行時に最大の効率を出すようにできるだけ頑張ってみよう。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> parallel_is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="bu">std::</span>size_t cores = <span class="bu">std::</span>thread<span class="bu">::</span>hardware_concurrency() ;
    cores = <span class="bu">std::</span>min( input.size(), cores ) ;

    <span class="bu">std::</span>vector&lt; <span class="bu">std::</span>future&lt;<span class="dt">bool</span>&gt; &gt; futures( cores ) ;

    <span class="kw">auto</span> step = input.size() / cores ;
    <span class="kw">auto</span> remainder = input.size() % cores ;

    <span class="kw">auto</span> first = <span class="bu">std::</span>begin(input) ;
    <span class="kw">auto</span> last = first + step + remainder ;

    <span class="cf">for</span> ( <span class="kw">auto</span> &amp; f : futures )
    {
        f = <span class="bu">std::</span>async( [=]{ <span class="cf">return</span> <span class="bu">std::</span>all_of( first, last, [](<span class="kw">auto</span> x){ <span class="cf">return</span> x &lt; <span class="dv">100</span> ;} ) ; } ) ;

        first = last ;
        last = first + step ;
    }

    <span class="cf">for</span> ( <span class="kw">auto</span> &amp; f : futures )
    {
        <span class="cf">if</span> ( f.get() == <span class="kw">false</span> )
            <span class="cf">return</span> <span class="kw">false</span> ;
    }
    <span class="cf">return</span> <span class="kw">true</span> ;
}</code></pre></div>
<p>もうわけがわからない。</p>
<p>このような並列化をそれぞれのアルゴリズムに対して自前で実装するのは面倒だ。そこで、C++17では標準で並列実行してくれる並列アルゴリズム(Parallelism)が追加された。</p>
<h2 id="使い方-4">使い方</h2>
<p>並列アルゴリズムは既存のアルゴリズムのオーバーロードとして追加されている。</p>
<p>以下は既存のアルゴリズムであるall_ofの宣言だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> InputIterator, <span class="kw">class</span> Predicate&gt;
<span class="dt">bool</span> all_of(InputIterator first, InputIterator last, Predicate pred);</code></pre></div>
<p>並列アルゴリズム版のall_ofは以下のような宣言になる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">class</span> ExecutionPolicy, <span class="kw">class</span> ForwardIterator, <span class="kw">class</span> Predicate&gt;
<span class="dt">bool</span> any_of(ExecutionPolicy&amp;&amp; exec, ForwardIterator first, ForwardIterator last, Predicate pred);</code></pre></div>
<p>並列アルゴリズムには、テンプレート仮引数としてExecutionPolicyが追加されていて第一引数に取る。これを実行時ポリシーと呼ぶ。</p>
<p>実行時ポリシーは&lt;execution&gt;で定義されている関数ディスパッチ用のタグ型で、std::execution::seq, std::execution::par, std::execution::par_unseqがある。</p>
<p>複数のスレッドによる並列実行を行うには、std::execution::parを使う。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt; <span class="kw">typename</span> Container &gt;
<span class="dt">bool</span> is_all_of_less_than_100( Container <span class="at">const</span> &amp; input )
{
    <span class="cf">return</span> <span class="bu">std::</span>all_of( <span class="bu">std::</span>execution<span class="bu">::</span>par,
        <span class="bu">std::</span>begin(input), <span class="bu">std::</span>end(input),
        []( <span class="kw">auto</span> x ){ <span class="cf">return</span> x &lt; <span class="dv">100</span> ; } ) ;
}</code></pre></div>
<p>std::execution::seqを渡すと既存のアルゴリズムと同じシーケンシャル実行になる。std::execution::parを渡すとパラレル実行になる。std::execution::par_unseqは並列実行かつベクトル実行になる。</p>
<p>C++17には実行ポリシーを受け取るアルゴリズムのオーバーロード関数が追加されている。</p>
<h2 id="並列アルゴリズム詳細">並列アルゴリズム詳細</h2>
<h3 id="並列アルゴリズム-1">並列アルゴリズム</h3>
<p>並列アルゴリズム(parallel algorithm)とは、ExecutionPolicy(実行ポリシー)というテンプレートパラメーターのある関数テンプレートのことだ。既存の&lt;algorithm&gt;とC++14で追加された一部の関数テンプレートが、並列アルゴリズムに対応している。</p>
<p>並列アルゴリズムはイテレーター、仕様上定められた操作、ユーザーの提供する関数オブジェクトによる操作、仕様上定められた関数オブジェクトに対する操作によって、オブジェクトにアクセスする。そのような関数群を、要素アクセス関数(element access functions)と呼ぶ。</p>
<p>例えば、std::sortは以下のような要素アクセス関数を持つ。</p>
<ul>
<li>テンプレート実引数で与えられたランダムアクセスイテレーター</li>
<li>要素に対するswap関数の適用</li>
<li>ユーザー提供されたCompare関数オブジェクト</li>
</ul>
<p>並列アルゴリズムが使う要素アクセス関数は、並列実行にともなう様々な制約を満たさなければならない。</p>
<h3 id="ユーザー提供する関数オブジェクトの制約">ユーザー提供する関数オブジェクトの制約</h3>
<p>並列アルゴリズムのうち、テンプレートパラメーター名が、Predicate, BinaryPredicate, Compare, UnaryOperation, BinaryOperation, BinaryOperation1, BinaryOperation2となってるものは、関数オブジェクトとしてユーザーがアルゴリズムに提供するものである。このようなユーザー提供の関数オブジェクトには、並列アルゴリズムに渡す際の制約がある。</p>
<ul>
<li>実引数で与えられたオブジェクトを直接、間接に変更してはならない</li>
<li>実引数で与えられたオブジェクトの一意性に依存してはならない</li>
<li>データ競合と同期</li>
</ul>
<p>一部の特殊なアルゴリズムには例外もあるが、ほとんどの並列アルゴリズムではこの制約を満たさなければならない。</p>
<h4 id="実引数で与えられたオブジェクトを直接間接に変更してはならない">実引数で与えられたオブジェクトを直接、間接に変更してはならない</h4>
<p>ユーザー提供の関数オブジェクトは実引数で与えられたオブジェクトを直接、間接に変更してはならない。</p>
<p>つまり、以下のようなコードは違法だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;
    <span class="bu">std::</span>all_of( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [](<span class="kw">auto</span> &amp; x){ ++x ; <span class="cf">return</span> <span class="kw">true</span> ; } ) ;
    <span class="co">// エラー</span>
}</code></pre></div>
<p>これは、ユーザー提供の関数オブジェクトが実引数をlvalueリファレンスで受け取って変更しているので、並列アルゴリズムの制約を満たさない。</p>
<p>std::for_eachはイテレーターが変更可能な要素を返す場合、ユーザー提供の関数オブジェクトが実引数を変更することが可能だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;
    <span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [](<span class="kw">auto</span> &amp; x ){ ++x ; } ) ;
    <span class="co">// OK</span>
}</code></pre></div>
<p>これは、for_eachは仕様上そのように定められているからだ。</p>
<h4 id="実引数で与えられたオブジェクトの一意性に依存してはならない">実引数で与えられたオブジェクトの一意性に依存してはならない</h4>
<p>ユーザー提供の関数オブジェクトは実引数で与えられたオブジェクトの一意性に依存してはならない。</p>
<p>これはどういうことかというと、たとえば実引数で渡されたオブジェクトのアドレスを取得して、そのアドレスがアルゴリズムに渡したオブジェクトのアドレスと同じであることを期待するようなコードを書くことができない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="co">// 最後の要素へのポインター</span>
    <span class="dt">int</span> * ptr = &amp;c[<span class="dv">4</span>] ;

    <span class="bu">std::</span>all_of( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [=]( <span class="kw">auto</span> &amp; x ){
            <span class="cf">if</span> ( ptr == &amp;x )
                <span class="co">// 最後の要素なので特別な処理</span>
                <span class="co">// エラー</span>
        } ) ;
}</code></pre></div>
<p>これはなぜかというと、並列アルゴリズムはその並列処理の一環として、要素のコピーを作成し、そのコピーをユーザー提供の関数オブジェクトに渡すかもしれないからだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// 実装イメージ</span>

<span class="kw">template</span> &lt; <span class="kw">typename</span> ExecutionPolicy, <span class="kw">typename</span> ForwardIterator, <span class="kw">typename</span> Predicate &gt;
<span class="dt">bool</span> all_of( ExecutionPolicy &amp;&amp; exec, ForwardIterator first, ForwardIterator last, Predicate pred )
{
    <span class="cf">if</span> <span class="kw">constexpr</span> ( <span class="bu">std::</span>is_same_v&lt; ExecutionPolicy, <span class="bu">std::</span>execution<span class="bu">::</span>parallel_policy&gt; )
    {
        <span class="bu">std::</span>vector c( first, last ) ;
        do_all_of_par( <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c), pred ) ;
    }
}</code></pre></div>
<p>このため、オブジェクトの一意性に依存したコードを書くことはできない。</p>
<h4 id="データ競合と同期">データ競合と同期</h4>
<p>std::execution::sequenced_policyを渡した並列アルゴリズムによる要素アクセス関数の呼び出しは呼び出し側スレッドで実行される。パラレル実行ではない。</p>
<p>std::execution::parallel_policyを渡した並列アルゴリズムによる要素アクセス関数の呼び出しは、呼び出し側スレッドか、ライブラリ側で作られたスレッドのいずれかで実行される。それぞれの要素アクセス関数の呼び出しの同期は定められていない。そのため、要素アクセス関数はデータ競合やデッドロックを起こさないようにしなければならない。</p>
<p>以下のコードはデータ競合が発生するのでエラーとなる。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>par, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [&amp;]( <span class="kw">auto</span> x ){ sum += x } ) ;
    <span class="co">// エラー、データ競合</span>
}</code></pre></div>
<p>なぜならば、ユーザー提供の関数オブジェクトは複数のスレッドから同時に呼び出されるかもしれないからだ。</p>
<p>std::execution::parallel_unsequenced_policyの実行は変わっている。未規定のスレッドから同期されない実行が許されている。これは、パラレルベクトル実行で想定している実行媒体がスレッドのような強い実行保証のある実行媒体ではなく、SIMDやGPGPUのような極めて軽い実行媒体であるからだ。</p>
<p>その結果、要素アクセス関数は通常のデータ競合やデッドロックを防ぐための手段すら取れなくなる。なぜならば、スレッドは実行の途中に中断して別の処理をしたりするからだ。</p>
<p>例えば、以下のコードは動かない。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="dt">int</span> main()
{
    <span class="dt">int</span> sum = <span class="dv">0</span> ;
    <span class="bu">std::</span>mutex m ;

    <span class="bu">std::</span>vector&lt;<span class="dt">int</span>&gt; c = { <span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span> } ;

    <span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>par_unseq, <span class="bu">std::</span>begin(c), <span class="bu">std::</span>end(c),
        [&amp;]( <span class="kw">auto</span> x ) {
            <span class="bu">std::</span>scoped_lock l(m) ;
            sum += x ; 
        } ) ;
    <span class="co">// エラー</span>
}</code></pre></div>
<p>このコードはparallel_unsequenced_policyならば、非効率的ではあるが問題なく同期されてデータ競合なく動くコードだ。しかし、parallel_unsequenced_policyでは動かない。なぜならば、mutexのlockという同期をする関数を呼び出す体。</p>
<p>C++では、ストレージの確保解放以外の同期する標準ライブラリの関数をすべて、ベクトル化非安全(vectorization-unsafe)に分類している。ベクトル化非安全な関数はstd::execution::parallel_unsequenced_policyの要素アクセス関数内で呼び出すことはできない。</p>
<h3 id="例外">例外</h3>
<p>並列アルゴリズムの実行中に、一時メモリーの確保が必要になったが確保できない場合、std::bad_allocがthrowされる。</p>
<p>並列アルゴリズムの実行中に、要素アクセス関数の外に例外が投げられた場合、std::terminateが呼ばれる。</p>
<h3 id="実行ポリシー">実行ポリシー</h3>
<p>実行ポリシーはヘッダーファイル&lt;execution&gt;で定義されている。その定義は以下のようになっている。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> std {
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">struct</span> is_execution_policy;
<span class="kw">template</span>&lt;<span class="kw">class</span> T&gt; <span class="kw">inline</span> <span class="kw">constexpr</span> <span class="dt">bool</span> is_execution_policy_v = is_execution_policy&lt;T&gt;::value;
}

<span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> sequenced_policy;
<span class="kw">class</span> parallel_policy;
<span class="kw">class</span> parallel_unsequenced_policy;

<span class="kw">inline</span> <span class="kw">constexpr</span> sequenced_policy seq{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_policy par{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_unsequenced_policy par_unseq{ };

}</code></pre></div>
<h4 id="is_execution_policy-traits">is_execution_policy traits</h4>
<p>std::is_execution_policy&lt;T&gt;はTが実行ポリシー型であるかどうかを返すtraitsだ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="co">// false</span>
<span class="kw">constexpr</span> <span class="dt">bool</span> b1 = <span class="bu">std::</span>is_execution_policy_v&lt;<span class="dt">int</span>&gt; ;
<span class="co">// true</span>
<span class="kw">constexpr</span> <span class="dt">bool</span> b2 = <span class="bu">std::</span>is_execution_policy_v&lt;<span class="bu">std::</span>execution<span class="bu">::</span>sequenced_policy&gt; ;</code></pre></div>
<h4 id="シーケンス実行ポリシー">シーケンス実行ポリシー</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> sequenced_policy ;
<span class="kw">inline</span> <span class="kw">constexpr</span> sequenced_policy seq { } ;

}</code></pre></div>
<p>シーケンス実行ポリシーは、並列アルゴリズムにパラレル実行を行わせないためのポリシーだ。この実行ポリシーが渡された場合、処理は呼び出し元のスレッドだけで行われる。</p>
<h4 id="パラレル実行ポリシー">パラレル実行ポリシー</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> parallel_policy ;
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_policy par { } ;

}</code></pre></div>
<p>パラレル実行ポリシーは、並列アルゴリズムにパラレル実行を行わせるためのポリシーだ。この実行ポリシーが渡された場合、処理は呼び出し元のスレッドと、ライブラリが作成したスレッドを用いる。</p>
<h4 id="パラレル非シーケンス実行ポリシー">パラレル非シーケンス実行ポリシー</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">class</span> parallel_unsequenced_policy ;
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_unsequenced_policy par_unseq { } ;

}</code></pre></div>
<p>パラレル非シーケンス実行ポリシーは、並列アルゴリズムにパラレル実行かつベクトル実行を行わせるためのポリシーだ。この実行ポリシーが渡された場合、処理は複数のスレッドと、SIMDやGPGPUのようなベクトル実行による並列化を行う。</p>
<h4 id="実行ポリシーオブジェクト">実行ポリシーオブジェクト</h4>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">namespace</span> <span class="bu">std::</span>execution {

<span class="kw">inline</span> <span class="kw">constexpr</span> sequenced_policy seq{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_policy par{ };
<span class="kw">inline</span> <span class="kw">constexpr</span> parallel_unsequenced_policy par_unseq{ };

}</code></pre></div>
<p>実行ポリシーの型を直接書くのは面倒だ。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>parallel_policy{}, ... ) ;</code></pre></div>
<p>そのため、標準ライブラリは実行ポリシーのオブジェクトを用意している。seqとparとpar_unseqがある。</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="bu">std::</span>for_each( <span class="bu">std::</span>execution<span class="bu">::</span>par, ... ) ;</code></pre></div>
<p>並列アルゴリズムを使うには、このオブジェクトを並列アルゴリズムの第一引数に渡すことになる。</p>
</body>
</html>
